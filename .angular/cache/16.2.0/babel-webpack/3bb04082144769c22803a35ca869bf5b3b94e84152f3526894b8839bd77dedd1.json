{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { NgZone, PLATFORM_ID, Injectable, Inject, InjectionToken, inject, INJECTOR, ɵglobal, ErrorHandler, Optional, SkipSelf, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport * as i5 from '@ngxs/store/internals';\nimport { memoize, INITIAL_STATE_TOKEN, NgxsBootstrapper, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subject, BehaviorSubject, of, forkJoin, throwError, EMPTY, from, isObservable } from 'rxjs';\nimport { filter, map, share, shareReplay, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, distinctUntilChanged, tap, startWith, pairwise } from 'rxjs/operators';\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n  if (action.constructor && action.constructor.type) {\n    return action.constructor.type;\n  } else {\n    return action.type;\n  }\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n  const type1 = getActionTypeFromInstance(action1);\n  return function (action2) {\n    return type1 === getActionTypeFromInstance(action2);\n  };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n  obj = Object.assign({}, obj);\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n    }\n    return acc && acc[part];\n  }, obj);\n  return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);\n/**\n * Simple object check.\n *\n *    isObject({a:1}) //=> true\n *    isObject(1) //=> false\n *\n * @ignore\n */\nconst isObject$1 = item => {\n  return item && typeof item === 'object' && !Array.isArray(item);\n};\n/**\n * Deep merge two objects.\n *\n *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}\n *\n * @param base base object onto which `sources` will be applied\n */\nconst mergeDeep = (base, ...sources) => {\n  if (!sources.length) return base;\n  const source = sources.shift();\n  if (isObject$1(base) && isObject$1(source)) {\n    for (const key in source) {\n      if (isObject$1(source[key])) {\n        if (!base[key]) Object.assign(base, {\n          [key]: {}\n        });\n        mergeDeep(base[key], source[key]);\n      } else {\n        Object.assign(base, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(base, ...sources);\n};\nfunction throwStateNameError(name) {\n  throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n  throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n  throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n  throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n  throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n  throw new Error('Selectors only work on methods.');\n}\nfunction getZoneWarningMessage() {\n  return 'Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' + 'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' + 'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })';\n}\nfunction getUndecoratedStateInIvyWarningMessage(name) {\n  return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction throwSelectFactoryNotConnectedError() {\n  throw new Error('You have forgotten to import the NGXS module!');\n}\nfunction throwPatchingArrayError() {\n  throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n  throw new Error('Patching primitives is not supported.');\n}\nclass DispatchOutsideZoneNgxsExecutionStrategy {\n  constructor(_ngZone, _platformId) {\n    this._ngZone = _ngZone;\n    this._platformId = _platformId;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      verifyZoneIsNotNooped(_ngZone);\n    }\n  }\n  enter(func) {\n    if (isPlatformServer(this._platformId)) {\n      return this.runInsideAngular(func);\n    }\n    return this.runOutsideAngular(func);\n  }\n  leave(func) {\n    return this.runInsideAngular(func);\n  }\n  runInsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return func();\n    }\n    return this._ngZone.run(func);\n  }\n  runOutsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return this._ngZone.runOutsideAngular(func);\n    }\n    return func();\n  }\n}\n/** @nocollapse */\nDispatchOutsideZoneNgxsExecutionStrategy.ɵfac = function DispatchOutsideZoneNgxsExecutionStrategy_Factory(t) {\n  return new (t || DispatchOutsideZoneNgxsExecutionStrategy)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */\nDispatchOutsideZoneNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DispatchOutsideZoneNgxsExecutionStrategy,\n  factory: DispatchOutsideZoneNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DispatchOutsideZoneNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n// Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\nfunction verifyZoneIsNotNooped(ngZone) {\n  // `NoopNgZone` is not exposed publicly as it doesn't expect\n  // to be used outside of the core Angular code, thus we just have\n  // to check if the zone doesn't extend or instanceof `NgZone`.\n  if (ngZone instanceof NgZone) {\n    return;\n  }\n  console.warn(getZoneWarningMessage());\n}\nconst ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\nconst ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');\nconst FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');\nconst NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nconst META_KEY = 'NGXS_META';\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nconst SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n/**\n * The NGXS config settings.\n */\nclass NgxsConfig {\n  constructor() {\n    /**\n     * Defining the default state before module initialization\n     * This is convenient if we need to create a define our own set of states.\n     * @deprecated will be removed after v4\n     * (default: {})\n     */\n    this.defaultsState = {};\n    /**\n     * Defining shared selector options\n     */\n    this.selectorOptions = {\n      injectContainerState: true,\n      suppressErrors: true // TODO: default is true in v3, will change in v4\n    };\n\n    this.compatibility = {\n      strictContentSecurityPolicy: false\n    };\n    this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n  }\n}\n/** @nocollapse */\nNgxsConfig.ɵfac = function NgxsConfig_Factory(t) {\n  return new (t || NgxsConfig)();\n};\n/** @nocollapse */\nNgxsConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsConfig,\n  factory: function NgxsConfig_Factory(t) {\n    let r = null;\n    if (t) {\n      r = new t();\n    } else {\n      r = (options => mergeDeep(new NgxsConfig(), options))(i0.ɵɵinject(ROOT_OPTIONS));\n    }\n    return r;\n  },\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root',\n      useFactory: options => mergeDeep(new NgxsConfig(), options),\n      deps: [ROOT_OPTIONS]\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n}\nclass NoopNgxsExecutionStrategy {\n  enter(func) {\n    return func();\n  }\n  leave(func) {\n    return func();\n  }\n}\n/** @nocollapse */\nNoopNgxsExecutionStrategy.ɵfac = function NoopNgxsExecutionStrategy_Factory(t) {\n  return new (t || NoopNgxsExecutionStrategy)();\n};\n/** @nocollapse */\nNoopNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NoopNgxsExecutionStrategy,\n  factory: NoopNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NoopNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * The strategy that might be provided by users through `options.executionStrategy`.\n */\nconst USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');\n/*\n * Internal execution strategy injection token\n */\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY', {\n  providedIn: 'root',\n  factory: () => {\n    const injector = inject(INJECTOR);\n    const executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);\n    return executionStrategy ? injector.get(executionStrategy) : injector.get(typeof ɵglobal.Zone !== 'undefined' ? DispatchOutsideZoneNgxsExecutionStrategy : NoopNgxsExecutionStrategy);\n  }\n});\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ensureStoreMetadata$1(target) {\n  if (!target.hasOwnProperty(META_KEY)) {\n    const defaultMetadata = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n      makeRootSelector(context) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n      children: []\n    };\n    Object.defineProperty(target, META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return getStoreMetadata$1(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction getStoreMetadata$1(target) {\n  return target[META_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ensureSelectorMetadata$1(target) {\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n    const defaultMetadata = {\n      makeRootSelector: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null,\n      getSelectorOptions: () => ({})\n    };\n    Object.defineProperty(target, SELECTOR_META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return getSelectorMetadata$1(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction getSelectorMetadata$1(target) {\n  return target[SELECTOR_META_KEY];\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n  const copyOfPaths = paths.slice();\n  return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n  const segments = paths;\n  let seg = 'store.' + segments[0];\n  let i = 0;\n  const l = segments.length;\n  let expr = seg;\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n  const fn = new Function('store', 'return ' + expr + ';');\n  return fn;\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nfunction propGetter(paths, config) {\n  if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n    return compliantPropGetter(paths);\n  } else {\n    return fastPropGetter(paths);\n  }\n}\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n  const findName = stateClass => {\n    const meta = stateClasses.find(g => g === stateClass);\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {\n      throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n    }\n    return meta[META_KEY].name;\n  };\n  return stateClasses.reduce((result, stateClass) => {\n    const {\n      name,\n      children\n    } = stateClass[META_KEY];\n    result[name] = (children || []).map(findName);\n    return result;\n  }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n  return states.reduce((result, stateClass) => {\n    const meta = stateClass[META_KEY];\n    result[meta.name] = stateClass;\n    return result;\n  }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, newObj = {}) {\n  const visit = (child, keyToFind) => {\n    for (const key in child) {\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n        const parent = visit(child, key);\n        return parent !== null ? `${parent}.${key}` : key;\n      }\n    }\n    return null;\n  };\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const parent = visit(obj, key);\n      newObj[key] = parent ? `${parent}.${key}` : key;\n    }\n  }\n  return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n  const sorted = [];\n  const visited = {};\n  const visit = (name, ancestors = []) => {\n    if (!Array.isArray(ancestors)) {\n      ancestors = [];\n    }\n    ancestors.push(name);\n    visited[name] = true;\n    graph[name].forEach(dep => {\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n      }\n      if (visited[dep]) {\n        return;\n      }\n      visit(dep, ancestors.slice(0));\n    });\n    if (sorted.indexOf(name) < 0) {\n      sorted.push(name);\n    }\n  };\n  Object.keys(graph).forEach(k => visit(k));\n  return sorted.reverse();\n}\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null || typeof obj === 'function';\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n  return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"DISPATCHED\" /* Dispatched */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"SUCCESSFUL\" /* Successful */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"CANCELED\" /* Canceled */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n  const allowedStatuses = [\"SUCCESSFUL\" /* Successful */, \"CANCELED\" /* Canceled */, \"ERRORED\" /* Errored */];\n\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"ERRORED\" /* Errored */]);\n}\n\nfunction ofActionOperator(allowedTypes, statuses,\n// This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,\n// since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`\n// defaults to `any`, thus there is no sense from union type.\nmapOperator = mapAction) {\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n  return function (o) {\n    return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n  };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n  return filter(ctx => {\n    const actionType = getActionTypeFromInstance(ctx.action);\n    const typeMatch = allowedTypes[actionType];\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n    return typeMatch && statusMatch;\n  });\n}\nfunction mapActionResult() {\n  return map(({\n    action,\n    status,\n    error\n  }) => {\n    return {\n      action,\n      result: {\n        successful: \"SUCCESSFUL\" /* Successful */ === status,\n        canceled: \"CANCELED\" /* Canceled */ === status,\n        error\n      }\n    };\n  });\n}\nfunction mapAction() {\n  return map(ctx => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n  return types.reduce((filterMap, klass) => {\n    filterMap[getActionTypeFromInstance(klass)] = true;\n    return filterMap;\n  }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n  return statuses.reduce((filterMap, status) => {\n    filterMap[status] = true;\n    return filterMap;\n  }, {});\n}\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n  return source => {\n    return new Observable(sink => {\n      return source.subscribe({\n        next(value) {\n          ngxsExecutionStrategy.leave(() => sink.next(value));\n        },\n        error(error) {\n          ngxsExecutionStrategy.leave(() => sink.error(error));\n        },\n        complete() {\n          ngxsExecutionStrategy.leave(() => sink.complete());\n        }\n      });\n    });\n  };\n}\nclass InternalNgxsExecutionStrategy {\n  constructor(_executionStrategy) {\n    this._executionStrategy = _executionStrategy;\n  }\n  enter(func) {\n    return this._executionStrategy.enter(func);\n  }\n  leave(func) {\n    return this._executionStrategy.leave(func);\n  }\n}\n/** @nocollapse */\nInternalNgxsExecutionStrategy.ɵfac = function InternalNgxsExecutionStrategy_Factory(t) {\n  return new (t || InternalNgxsExecutionStrategy)(i0.ɵɵinject(NGXS_EXECUTION_STRATEGY));\n};\n/** @nocollapse */\nInternalNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalNgxsExecutionStrategy,\n  factory: InternalNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_EXECUTION_STRATEGY]\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * This wraps the provided function, and will enforce the following:\n * - The calls will execute in the order that they are made\n * - A call will only be initiated when the previous call has completed\n * - If there is a call currently executing then the new call will be added\n *   to the queue and the function will return immediately\n *\n * NOTE: The following assumptions about the operation must hold true:\n * - The operation is synchronous in nature\n * - If any asynchronous side effects of the call exist, it should not\n *   have any bearing on the correctness of the next call in the queue\n * - The operation has a void return\n * - The caller should not assume that the call has completed upon\n *   return of the function\n * - The caller can assume that all the queued calls will complete\n *   within the current microtask\n * - The only way that a call will encounter another call in the queue\n *   would be if the call at the front of the queue initiated this call\n *   as part of its synchronous execution\n */\nfunction orderedQueueOperation(operation) {\n  const callsQueue = [];\n  let busyPushingNext = false;\n  return function callOperation(...args) {\n    if (busyPushingNext) {\n      callsQueue.unshift(args);\n      return;\n    }\n    busyPushingNext = true;\n    operation(...args);\n    while (callsQueue.length > 0) {\n      const nextCallArgs = callsQueue.pop();\n      nextCallArgs && operation(...nextCallArgs);\n    }\n    busyPushingNext = false;\n  };\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this._orderedNext = orderedQueueOperation(value => super.next(value));\n  }\n  next(value) {\n    this._orderedNext(value);\n  }\n}\n/**\n * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard BehaviorSubject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new BehaviorSubject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedBehaviorSubject extends BehaviorSubject {\n  constructor(value) {\n    super(value);\n    this._orderedNext = orderedQueueOperation(value => super.next(value));\n    this._currentValue = value;\n  }\n  getValue() {\n    return this._currentValue;\n  }\n  next(value) {\n    this._currentValue = value;\n    this._orderedNext(value);\n  }\n}\n\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nclass InternalActions extends OrderedSubject {\n  ngOnDestroy() {\n    this.complete();\n  }\n}\n/** @nocollapse */\nInternalActions.ɵfac = /* @__PURE__ */function () {\n  let ɵInternalActions_BaseFactory;\n  return function InternalActions_Factory(t) {\n    return (ɵInternalActions_BaseFactory || (ɵInternalActions_BaseFactory = i0.ɵɵgetInheritedFactory(InternalActions)))(t || InternalActions);\n  };\n}();\n/** @nocollapse */\nInternalActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalActions,\n  factory: InternalActions.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalActions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nclass Actions extends Observable {\n  constructor(internalActions$, internalExecutionStrategy) {\n    const sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy),\n    // The `InternalActions` subject emits outside of the Angular zone.\n    // We have to re-enter the Angular zone for any incoming consumer.\n    // The `share()` operator reduces the number of change detections.\n    // This would call leave only once for any stream emission across all active subscribers.\n    share());\n    super(observer => {\n      const childSubscription = sharedInternalActions$.subscribe({\n        next: ctx => observer.next(ctx),\n        error: error => observer.error(error),\n        complete: () => observer.complete()\n      });\n      observer.add(childSubscription);\n    });\n  }\n}\n/** @nocollapse */\nActions.ɵfac = function Actions_Factory(t) {\n  return new (t || Actions)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalNgxsExecutionStrategy));\n};\n/** @nocollapse */\nActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Actions,\n  factory: Actions.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Actions, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: InternalActions\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }];\n  }, null);\n})();\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nconst compose = funcs => (...args) => {\n  const curr = funcs.shift();\n  return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n\n/**\n * This operator is used for piping the observable result\n * from the `dispatch()`. It has a \"smart\" error handling\n * strategy that allows us to decide whether we propagate\n * errors to Angular's `ErrorHandler` or enable users to\n * handle them manually. We consider following cases:\n * 1) `store.dispatch()` (no subscribe) -> call `handleError()`\n * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`\n * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`\n * 4) `toPromise()` without `catch` -> do `handleError()`\n * 5) `toPromise()` with `catch` -> don't `handleError()`\n */\nfunction ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {\n  return source => {\n    let subscribed = false;\n    source.subscribe({\n      error: error => {\n        // Do not trigger change detection for a microtask. This depends on the execution\n        // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`\n        // leaves the Angular zone.\n        ngxsExecutionStrategy.enter(() => Promise.resolve().then(() => {\n          if (!subscribed) {\n            ngxsExecutionStrategy.leave(() => internalErrorReporter.reportErrorSafely(error));\n          }\n        }));\n      }\n    });\n    return new Observable(subscriber => {\n      subscribed = true;\n      return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);\n    });\n  };\n}\nclass InternalErrorReporter {\n  constructor(_injector) {\n    this._injector = _injector;\n    /** Will be set lazily to be backward compatible. */\n    this._errorHandler = null;\n  }\n  reportErrorSafely(error) {\n    if (this._errorHandler === null) {\n      this._errorHandler = this._injector.get(ErrorHandler);\n    }\n    // The `try-catch` is used to avoid handling the error twice. Suppose we call\n    // `handleError` which re-throws the error internally. The re-thrown error will\n    // be caught by zone.js which will then get to the `zone.onError.emit()` and the\n    // `onError` subscriber will call `handleError` again.\n    try {\n      this._errorHandler.handleError(error);\n    } catch (_a) {}\n  }\n}\n/** @nocollapse */\nInternalErrorReporter.ɵfac = function InternalErrorReporter_Factory(t) {\n  return new (t || InternalErrorReporter)(i0.ɵɵinject(i0.Injector));\n};\n/** @nocollapse */\nInternalErrorReporter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalErrorReporter,\n  factory: InternalErrorReporter.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalErrorReporter, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.Injector\n    }];\n  }, null);\n})();\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nclass StateStream extends OrderedBehaviorSubject {\n  constructor() {\n    super({});\n  }\n  ngOnDestroy() {\n    // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.\n    // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users\n    // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.\n    this.complete();\n  }\n}\n/** @nocollapse */\nStateStream.ɵfac = function StateStream_Factory(t) {\n  return new (t || StateStream)();\n};\n/** @nocollapse */\nStateStream.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateStream,\n  factory: StateStream.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateStream, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\nclass PluginManager {\n  constructor(_parentManager, _pluginHandlers) {\n    this._parentManager = _parentManager;\n    this._pluginHandlers = _pluginHandlers;\n    this.plugins = [];\n    this.registerHandlers();\n  }\n  get rootPlugins() {\n    return this._parentManager && this._parentManager.plugins || this.plugins;\n  }\n  registerHandlers() {\n    const pluginHandlers = this.getPluginHandlers();\n    this.rootPlugins.push(...pluginHandlers);\n  }\n  getPluginHandlers() {\n    const handlers = this._pluginHandlers || [];\n    return handlers.map(plugin => plugin.handle ? plugin.handle.bind(plugin) : plugin);\n  }\n}\n/** @nocollapse */\nPluginManager.ɵfac = function PluginManager_Factory(t) {\n  return new (t || PluginManager)(i0.ɵɵinject(PluginManager, 12), i0.ɵɵinject(NGXS_PLUGINS, 8));\n};\n/** @nocollapse */\nPluginManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PluginManager,\n  factory: PluginManager.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PluginManager, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: PluginManager,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_PLUGINS]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nclass InternalDispatchedActionResults extends Subject {}\n/** @nocollapse */\nInternalDispatchedActionResults.ɵfac = /* @__PURE__ */function () {\n  let ɵInternalDispatchedActionResults_BaseFactory;\n  return function InternalDispatchedActionResults_Factory(t) {\n    return (ɵInternalDispatchedActionResults_BaseFactory || (ɵInternalDispatchedActionResults_BaseFactory = i0.ɵɵgetInheritedFactory(InternalDispatchedActionResults)))(t || InternalDispatchedActionResults);\n  };\n}();\n/** @nocollapse */\nInternalDispatchedActionResults.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalDispatchedActionResults,\n  factory: InternalDispatchedActionResults.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatchedActionResults, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nclass InternalDispatcher {\n  constructor(_actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy, _internalErrorReporter) {\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._pluginManager = _pluginManager;\n    this._stateStream = _stateStream;\n    this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n    this._internalErrorReporter = _internalErrorReporter;\n  }\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions) {\n    const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n    return result.pipe(ngxsErrorHandler(this._internalErrorReporter, this._ngxsExecutionStrategy));\n  }\n  dispatchByEvents(actionOrActions) {\n    if (Array.isArray(actionOrActions)) {\n      if (actionOrActions.length === 0) return of(this._stateStream.getValue());\n      return forkJoin(actionOrActions.map(action => this.dispatchSingle(action)));\n    } else {\n      return this.dispatchSingle(actionOrActions);\n    }\n  }\n  dispatchSingle(action) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const type = getActionTypeFromInstance(action);\n      if (!type) {\n        const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n        return throwError(error);\n      }\n    }\n    const prevState = this._stateStream.getValue();\n    const plugins = this._pluginManager.plugins;\n    return compose([...plugins, (nextState, nextAction) => {\n      if (nextState !== prevState) {\n        this._stateStream.next(nextState);\n      }\n      const actionResult$ = this.getActionResultStream(nextAction);\n      actionResult$.subscribe(ctx => this._actions.next(ctx));\n      this._actions.next({\n        action: nextAction,\n        status: \"DISPATCHED\" /* Dispatched */\n      });\n      return this.createDispatchObservable(actionResult$);\n    }])(prevState, action).pipe(shareReplay());\n  }\n  getActionResultStream(action) {\n    return this._actionResults.pipe(filter(ctx => ctx.action === action && ctx.status !== \"DISPATCHED\" /* Dispatched */), take(1), shareReplay());\n  }\n  createDispatchObservable(actionResult$) {\n    return actionResult$.pipe(exhaustMap(ctx => {\n      switch (ctx.status) {\n        case \"SUCCESSFUL\" /* Successful */:\n          return of(this._stateStream.getValue());\n        case \"ERRORED\" /* Errored */:\n          return throwError(ctx.error);\n        default:\n          return EMPTY;\n      }\n    })).pipe(shareReplay());\n  }\n}\n/** @nocollapse */\nInternalDispatcher.ɵfac = function InternalDispatcher_Factory(t) {\n  return new (t || InternalDispatcher)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(PluginManager), i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(InternalErrorReporter));\n};\n/** @nocollapse */\nInternalDispatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalDispatcher,\n  factory: InternalDispatcher.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatcher, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: InternalActions\n    }, {\n      type: InternalDispatchedActionResults\n    }, {\n      type: PluginManager\n    }, {\n      type: StateStream\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }, {\n      type: InternalErrorReporter\n    }];\n  }, null);\n})();\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = o => {\n  Object.freeze(o);\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};\n\n/**\n * @ignore\n */\nclass InternalStateOperations {\n  constructor(_stateStream, _dispatcher, _config) {\n    this._stateStream = _stateStream;\n    this._dispatcher = _dispatcher;\n    this._config = _config;\n  }\n  /**\n   * Returns the root state operators.\n   */\n  getRootStateOperations() {\n    const rootStateOperations = {\n      getState: () => this._stateStream.getValue(),\n      setState: newState => this._stateStream.next(newState),\n      dispatch: actionOrActions => this._dispatcher.dispatch(actionOrActions)\n    };\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      return this._config.developmentMode ? ensureStateAndActionsAreImmutable(rootStateOperations) : rootStateOperations;\n    } else {\n      return rootStateOperations;\n    }\n  }\n  setStateToTheCurrentWithNew(results) {\n    const stateOperations = this.getRootStateOperations();\n    // Get our current stream\n    const currentState = stateOperations.getState();\n    // Set the state to the current + new\n    stateOperations.setState(Object.assign(Object.assign({}, currentState), results.defaults));\n  }\n}\n/** @nocollapse */\nInternalStateOperations.ɵfac = function InternalStateOperations_Factory(t) {\n  return new (t || InternalStateOperations)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalDispatcher), i0.ɵɵinject(NgxsConfig));\n};\n/** @nocollapse */\nInternalStateOperations.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalStateOperations,\n  factory: InternalStateOperations.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalStateOperations, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: StateStream\n    }, {\n      type: InternalDispatcher\n    }, {\n      type: NgxsConfig\n    }];\n  }, null);\n})();\nfunction ensureStateAndActionsAreImmutable(root) {\n  return {\n    getState: () => root.getState(),\n    setState: value => {\n      const frozenValue = deepFreeze(value);\n      return root.setState(frozenValue);\n    },\n    dispatch: actions => {\n      return root.dispatch(actions);\n    }\n  };\n}\nfunction simplePatch(value) {\n  return existingState => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (Array.isArray(value)) {\n        throwPatchingArrayError();\n      } else if (typeof value !== 'object') {\n        throwPatchingPrimitiveError();\n      }\n    }\n    const newState = Object.assign({}, existingState);\n    for (const key in value) {\n      // deep clone for patch compatibility\n      newState[key] = value[key];\n    }\n    return newState;\n  };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nclass StateContextFactory {\n  constructor(_internalStateOperations) {\n    this._internalStateOperations = _internalStateOperations;\n  }\n  /**\n   * Create the state context\n   */\n  createStateContext(mappedStore) {\n    const root = this._internalStateOperations.getRootStateOperations();\n    function getState(currentAppState) {\n      return getValue(currentAppState, mappedStore.path);\n    }\n    function setStateValue(currentAppState, newValue) {\n      const newAppState = setValue(currentAppState, mappedStore.path, newValue);\n      root.setState(newAppState);\n      return newAppState;\n      // In doing this refactoring I noticed that there is a 'bug' where the\n      // application state is returned instead of this state slice.\n      // This has worked this way since the beginning see:\n      // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n      // This needs to be fixed, but is a 'breaking' change.\n      // I will do this fix in a subsequent PR and we can decide how to handle it.\n    }\n\n    function setStateFromOperator(currentAppState, stateOperator) {\n      const local = getState(currentAppState);\n      const newValue = stateOperator(local);\n      return setStateValue(currentAppState, newValue);\n    }\n    function isStateOperator(value) {\n      return typeof value === 'function';\n    }\n    return {\n      getState() {\n        const currentAppState = root.getState();\n        return getState(currentAppState);\n      },\n      patchState(val) {\n        const currentAppState = root.getState();\n        const patchOperator = simplePatch(val);\n        return setStateFromOperator(currentAppState, patchOperator);\n      },\n      setState(val) {\n        const currentAppState = root.getState();\n        return isStateOperator(val) ? setStateFromOperator(currentAppState, val) : setStateValue(currentAppState, val);\n      },\n      dispatch(actions) {\n        return root.dispatch(actions);\n      }\n    };\n  }\n}\n/** @nocollapse */\nStateContextFactory.ɵfac = function StateContextFactory_Factory(t) {\n  return new (t || StateContextFactory)(i0.ɵɵinject(InternalStateOperations));\n};\n/** @nocollapse */\nStateContextFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateContextFactory,\n  factory: StateContextFactory.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateContextFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: InternalStateOperations\n    }];\n  }, null);\n})();\nclass StoreValidators {\n  static checkThatStateIsNamedCorrectly(name) {\n    if (!name) {\n      throwStateNamePropertyError();\n    } else if (!this.stateNameRegex.test(name)) {\n      throwStateNameError(name);\n    }\n  }\n  static checkThatStateNameIsUnique(stateName, state, statesByName) {\n    const existingState = statesByName[stateName];\n    if (existingState && existingState !== state) {\n      throwStateUniqueError(stateName, state.name, existingState.name);\n    }\n  }\n  static checkThatStateClassesHaveBeenDecorated(stateClasses) {\n    stateClasses.forEach(stateClass => {\n      if (!getStoreMetadata$1(stateClass)) {\n        throwStateDecoratorError(stateClass.name);\n      }\n    });\n  }\n}\nStoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n  if (jit_hasInjectableAnnotation(stateClass) || aot_hasNgInjectableDef(stateClass)) {\n    return;\n  }\n  console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));\n}\nfunction aot_hasNgInjectableDef(stateClass) {\n  // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n  // AOT mode because this property is added before runtime. If an application is running in\n  // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n  // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n  return !!stateClass.ɵprov;\n}\nfunction jit_hasInjectableAnnotation(stateClass) {\n  // `ɵprov` doesn't exist in JIT mode (for instance when running unit tests with Jest).\n  const annotations = stateClass.__annotations__ || [];\n  return annotations.some(annotation => (annotation === null || annotation === void 0 ? void 0 : annotation.ngMetadataName) === 'Injectable');\n}\n\n/**\n * Init action\n */\nclass InitState {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@INIT';\n  }\n}\n/**\n * Update action\n */\nclass UpdateState {\n  constructor(addedStates) {\n    this.addedStates = addedStates;\n  }\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@UPDATE_STATE';\n  }\n}\nconst NGXS_DEVELOPMENT_OPTIONS = new InjectionToken('NGXS_DEVELOPMENT_OPTIONS', {\n  providedIn: 'root',\n  factory: () => ({\n    warnOnUnhandledActions: true\n  })\n});\nclass NgxsUnhandledActionsLogger {\n  constructor(options) {\n    /**\n     * These actions should be ignored by default; the user can increase this\n     * list in the future via the `ignoreActions` method.\n     */\n    this._ignoredActions = new Set([InitState.type, UpdateState.type]);\n    if (typeof options.warnOnUnhandledActions === 'object') {\n      this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n    }\n  }\n  /**\n   * Adds actions to the internal list of actions that should be ignored.\n   */\n  ignoreActions(...actions) {\n    for (const action of actions) {\n      this._ignoredActions.add(action.type);\n    }\n  }\n  /** @internal */\n  warn(action) {\n    const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n    if (actionShouldBeIgnored) {\n      return;\n    }\n    action = action.constructor && action.constructor.name !== 'Object' ? action.constructor.name : action.type;\n    console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n  }\n}\n/** @nocollapse */\nNgxsUnhandledActionsLogger.ɵfac = function NgxsUnhandledActionsLogger_Factory(t) {\n  return new (t || NgxsUnhandledActionsLogger)(i0.ɵɵinject(NGXS_DEVELOPMENT_OPTIONS));\n};\n/** @nocollapse */\nNgxsUnhandledActionsLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsUnhandledActionsLogger,\n  factory: NgxsUnhandledActionsLogger.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsUnhandledActionsLogger, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_DEVELOPMENT_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n/**\n * The `StateFactory` class adds root and feature states to the graph.\n * This extracts state names from state classes, checks if they already\n * exist in the global graph, throws errors if their names are invalid, etc.\n * See its constructor, state factories inject state factories that are\n * parent-level providers. This is required to get feature states from the\n * injector on the same level.\n *\n * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.\n * The `StateFactory` is initialized on the feature level and goes through `...states`\n * to get them from the injector through `injector.get(state)`.\n * @ignore\n */\nclass StateFactory {\n  constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n    this._injector = _injector;\n    this._config = _config;\n    this._parentFactory = _parentFactory;\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._stateContextFactory = _stateContextFactory;\n    this._initialState = _initialState;\n    this._actionsSubscription = null;\n    this._states = [];\n    this._statesByName = {};\n    this._statePaths = {};\n    this.getRuntimeSelectorContext = memoize(() => {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const stateFactory = this;\n      function resolveGetter(key) {\n        const path = stateFactory.statePaths[key];\n        return path ? propGetter(path.split('.'), stateFactory._config) : null;\n      }\n      const context = this._parentFactory ? this._parentFactory.getRuntimeSelectorContext() : {\n        getStateGetter(key) {\n          let getter = resolveGetter(key);\n          if (getter) {\n            return getter;\n          }\n          return (...args) => {\n            // Late loaded getter\n            if (!getter) {\n              getter = resolveGetter(key);\n            }\n            return getter ? getter(...args) : undefined;\n          };\n        },\n        getSelectorOptions(localOptions) {\n          const globalSelectorOptions = stateFactory._config.selectorOptions;\n          return Object.assign(Object.assign({}, globalSelectorOptions), localOptions || {});\n        }\n      };\n      return context;\n    });\n  }\n  get states() {\n    return this._parentFactory ? this._parentFactory.states : this._states;\n  }\n  get statesByName() {\n    return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n  }\n  get statePaths() {\n    return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n  }\n  static cloneDefaults(defaults) {\n    let value = {};\n    if (Array.isArray(defaults)) {\n      value = defaults.slice();\n    } else if (isObject(defaults)) {\n      value = Object.assign({}, defaults);\n    } else if (defaults === undefined) {\n      value = {};\n    } else {\n      value = defaults;\n    }\n    return value;\n  }\n  ngOnDestroy() {\n    var _a;\n    (_a = this._actionsSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n  }\n  /**\n   * Add a new state to the global defs.\n   */\n  add(stateClasses) {\n    if (NG_DEV_MODE) {\n      StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);\n    }\n    const {\n      newStates\n    } = this.addToStatesMap(stateClasses);\n    if (!newStates.length) return [];\n    const stateGraph = buildGraph(newStates);\n    const sortedStates = topologicalSort(stateGraph);\n    const paths = findFullParentPath(stateGraph);\n    const nameGraph = nameToState(newStates);\n    const bootstrappedStores = [];\n    for (const name of sortedStates) {\n      const stateClass = nameGraph[name];\n      const path = paths[name];\n      const meta = stateClass[META_KEY];\n      this.addRuntimeInfoToMeta(meta, path);\n      // Note: previously we called `ensureStateClassIsInjectable` within the\n      // `State` decorator. This check is moved here because the `ɵprov` property\n      // will not exist on the class in JIT mode (because it's set asynchronously\n      // during JIT compilation through `Object.defineProperty`).\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        ensureStateClassIsInjectable(stateClass);\n      }\n      const stateMap = {\n        name,\n        path,\n        isInitialised: false,\n        actions: meta.actions,\n        instance: this._injector.get(stateClass),\n        defaults: StateFactory.cloneDefaults(meta.defaults)\n      };\n      // ensure our store hasn't already been added\n      // but don't throw since it could be lazy\n      // loaded from different paths\n      if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n        bootstrappedStores.push(stateMap);\n      }\n      this.states.push(stateMap);\n    }\n    return bootstrappedStores;\n  }\n  /**\n   * Add a set of states to the store and return the defaults\n   */\n  addAndReturnDefaults(stateClasses) {\n    const classes = stateClasses || [];\n    const mappedStores = this.add(classes);\n    const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n    return {\n      defaults,\n      states: mappedStores\n    };\n  }\n  connectActionHandlers() {\n    // Note: We have to connect actions only once when the `StateFactory`\n    //       is being created for the first time. This checks if we're in\n    //       a child state factory and the parent state factory already exists.\n    if (this._parentFactory || this._actionsSubscription !== null) {\n      return;\n    }\n    const dispatched$ = new Subject();\n    this._actionsSubscription = this._actions.pipe(filter(ctx => ctx.status === \"DISPATCHED\" /* Dispatched */), mergeMap(ctx => {\n      dispatched$.next(ctx);\n      const action = ctx.action;\n      return this.invokeActions(dispatched$, action).pipe(map(() => ({\n        action,\n        status: \"SUCCESSFUL\" /* Successful */\n      })), defaultIfEmpty({\n        action,\n        status: \"CANCELED\" /* Canceled */\n      }), catchError(error => of({\n        action,\n        status: \"ERRORED\" /* Errored */,\n        error\n      })));\n    })).subscribe(ctx => this._actionResults.next(ctx));\n  }\n  /**\n   * Invoke actions on the states.\n   */\n  invokeActions(dispatched$, action) {\n    const type = getActionTypeFromInstance(action);\n    const results = [];\n    // Determines whether the dispatched action has been handled, this is assigned\n    // to `true` within the below `for` loop if any `actionMetas` has been found.\n    let actionHasBeenHandled = false;\n    for (const metadata of this.states) {\n      const actionMetas = metadata.actions[type];\n      if (actionMetas) {\n        for (const actionMeta of actionMetas) {\n          const stateContext = this._stateContextFactory.createStateContext(metadata);\n          try {\n            let result = metadata.instance[actionMeta.fn](stateContext, action);\n            if (result instanceof Promise) {\n              result = from(result);\n            }\n            if (isObservable(result)) {\n              // If this observable has been completed w/o emitting\n              // any value then we wouldn't want to complete the whole chain\n              // of actions. Since if any observable completes then\n              // action will be canceled.\n              // For instance if any action handler would've had such statement:\n              // `handler(ctx) { return EMPTY; }`\n              // then the action will be canceled.\n              // See https://github.com/ngxs/store/issues/1568\n              result = result.pipe(mergeMap(value => {\n                if (value instanceof Promise) {\n                  return from(value);\n                }\n                if (isObservable(value)) {\n                  return value;\n                }\n                return of(value);\n              }), defaultIfEmpty({}));\n              if (actionMeta.options.cancelUncompleted) {\n                // todo: ofActionDispatched should be used with action class\n                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));\n              }\n            } else {\n              result = of({}).pipe(shareReplay());\n            }\n            results.push(result);\n          } catch (e) {\n            results.push(throwError(e));\n          }\n          actionHasBeenHandled = true;\n        }\n      }\n    }\n    // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n    // only during development.\n    if (NG_DEV_MODE && !actionHasBeenHandled) {\n      const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n      // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n      // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n      // didn't return `null` so we may ensure the module has been imported.\n      if (unhandledActionsLogger) {\n        unhandledActionsLogger.warn(action);\n      }\n    }\n    if (!results.length) {\n      results.push(of({}));\n    }\n    return forkJoin(results);\n  }\n  addToStatesMap(stateClasses) {\n    const newStates = [];\n    const statesMap = this.statesByName;\n    for (const stateClass of stateClasses) {\n      const stateName = getStoreMetadata$1(stateClass).name;\n      if (NG_DEV_MODE) {\n        StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);\n      }\n      const unmountedState = !statesMap[stateName];\n      if (unmountedState) {\n        newStates.push(stateClass);\n        statesMap[stateName] = stateClass;\n      }\n    }\n    return {\n      newStates\n    };\n  }\n  addRuntimeInfoToMeta(meta, path) {\n    this.statePaths[meta.name] = path;\n    // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n    // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n    // We will need to come up with an alternative in v4 because this is used by many plugins\n    meta.path = path;\n  }\n  hasBeenMountedAndBootstrapped(name, path) {\n    const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n    // This checks whether a state has been already added to the global graph and\n    // its lifecycle is in 'bootstrapped' state.\n    return this.statesByName[name] && valueIsBootstrappedInInitialState;\n  }\n}\n/** @nocollapse */\nStateFactory.ɵfac = function StateFactory_Factory(t) {\n  return new (t || StateFactory)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(StateFactory, 12), i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n};\n/** @nocollapse */\nStateFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateFactory,\n  factory: StateFactory.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateFactory, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.Injector\n    }, {\n      type: NgxsConfig\n    }, {\n      type: StateFactory,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: InternalActions\n    }, {\n      type: InternalDispatchedActionResults\n    }, {\n      type: StateContextFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [INITIAL_STATE_TOKEN]\n      }]\n    }];\n  }, null);\n})();\nfunction createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {\n  return context => {\n    const {\n      argumentSelectorFunctions,\n      selectorOptions\n    } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n    return function selectFromRoot(rootState) {\n      // Determine arguments from the app state using the selectors\n      const results = argumentSelectorFunctions.map(argFn => argFn(rootState));\n      // if the lambda tries to access a something on the\n      // state that doesn't exist, it will throw a TypeError.\n      // since this is quite usual behaviour, we simply return undefined if so.\n      try {\n        return memoizedSelectorFn(...results);\n      } catch (ex) {\n        if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n          return undefined;\n        }\n        throw ex;\n      }\n    };\n  };\n}\nfunction createMemoizedSelectorFn(originalFn, creationMetadata) {\n  const containerClass = creationMetadata && creationMetadata.containerClass;\n  const wrappedFn = function wrappedSelectorFn(...args) {\n    const returnValue = originalFn.apply(containerClass, args);\n    if (returnValue instanceof Function) {\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n    return returnValue;\n  };\n  const memoizedFn = memoize(wrappedFn);\n  Object.setPrototypeOf(memoizedFn, originalFn);\n  return memoizedFn;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n  const localSelectorOptions = selectorMetaData.getSelectorOptions();\n  const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n  const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n  const argumentSelectorFunctions = selectorsToApply.map(selector => {\n    const factory = getRootSelectorFactory(selector);\n    return factory(context);\n  });\n  return {\n    selectorOptions,\n    argumentSelectorFunctions\n  };\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n  const selectorsToApply = [];\n  const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;\n  if (containerClass && canInjectContainerState) {\n    // If we are on a state class, add it as the first selector parameter\n    const metadata = getStoreMetadata$1(containerClass);\n    if (metadata) {\n      selectorsToApply.push(containerClass);\n    }\n  }\n  if (selectors) {\n    selectorsToApply.push(...selectors);\n  }\n  return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n  const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n  return metadata && metadata.makeRootSelector || (() => selector);\n}\n\n// tslint:disable:unified-signatures\nclass Store {\n  constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n    this._stateStream = _stateStream;\n    this._internalStateOperations = _internalStateOperations;\n    this._config = _config;\n    this._internalExecutionStrategy = _internalExecutionStrategy;\n    this._stateFactory = _stateFactory;\n    /**\n     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n     */\n    this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n    this.initStateStream(initialStateValue);\n  }\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions) {\n    return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n  }\n  select(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return this._selectableStateStream.pipe(map(selectorFn), catchError(err => {\n      // if error is TypeError we swallow it to prevent usual errors with property access\n      const {\n        suppressErrors\n      } = this._config.selectorOptions;\n      if (err instanceof TypeError && suppressErrors) {\n        return of(undefined);\n      }\n      // rethrow other errors\n      return throwError(err);\n    }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n  }\n  selectOnce(selector) {\n    return this.select(selector).pipe(take(1));\n  }\n  selectSnapshot(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return selectorFn(this._stateStream.getValue());\n  }\n  /**\n   * Allow the user to subscribe to the root of the state\n   */\n  subscribe(fn) {\n    return this._selectableStateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\n  }\n  /**\n   * Return the raw value of the state.\n   */\n  snapshot() {\n    return this._internalStateOperations.getRootStateOperations().getState();\n  }\n  /**\n   * Reset the state to a specific point in time. This method is useful\n   * for plugin's who need to modify the state directly or unit testing.\n   */\n  reset(state) {\n    return this._internalStateOperations.getRootStateOperations().setState(state);\n  }\n  getStoreBoundSelectorFn(selector) {\n    const makeSelectorFn = getRootSelectorFactory(selector);\n    const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n    return makeSelectorFn(runtimeContext);\n  }\n  initStateStream(initialStateValue) {\n    const value = this._stateStream.value;\n    const storeIsEmpty = !value || Object.keys(value).length === 0;\n    if (storeIsEmpty) {\n      const defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;\n      const storeValues = defaultStateNotEmpty ? Object.assign(Object.assign({}, this._config.defaultsState), initialStateValue) : initialStateValue;\n      this._stateStream.next(storeValues);\n    }\n  }\n}\n/** @nocollapse */\nStore.ɵfac = function Store_Factory(t) {\n  return new (t || Store)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(StateFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n};\n/** @nocollapse */\nStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Store,\n  factory: Store.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Store, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: StateStream\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: NgxsConfig\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }, {\n      type: StateFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [INITIAL_STATE_TOKEN]\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nclass SelectFactory {\n  constructor(store, config) {\n    SelectFactory.store = store;\n    SelectFactory.config = config;\n  }\n  ngOnDestroy() {\n    SelectFactory.store = null;\n    SelectFactory.config = null;\n  }\n}\nSelectFactory.store = null;\nSelectFactory.config = null;\n/** @nocollapse */\nSelectFactory.ɵfac = function SelectFactory_Factory(t) {\n  return new (t || SelectFactory)(i0.ɵɵinject(Store), i0.ɵɵinject(NgxsConfig));\n};\n/** @nocollapse */\nSelectFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SelectFactory,\n  factory: SelectFactory.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SelectFactory, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: NgxsConfig\n    }];\n  }, null);\n})();\nclass LifecycleStateManager {\n  constructor(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {\n    this._store = _store;\n    this._internalErrorReporter = _internalErrorReporter;\n    this._internalStateOperations = _internalStateOperations;\n    this._stateContextFactory = _stateContextFactory;\n    this._bootstrapper = _bootstrapper;\n    this._destroy$ = new Subject();\n  }\n  ngOnDestroy() {\n    this._destroy$.next();\n  }\n  ngxsBootstrap(action, results) {\n    this._internalStateOperations.getRootStateOperations().dispatch(action).pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._bootstrapper.appBootstrapped$), filter(appBootstrapped => !!appBootstrapped), catchError(error => {\n      // The `SafeSubscriber` (which is used by most RxJS operators) re-throws\n      // errors asynchronously (`setTimeout(() => { throw error })`). This might\n      // break existing user's code or unit tests. We catch the error manually to\n      // be backward compatible with the old behavior.\n      this._internalErrorReporter.reportErrorSafely(error);\n      return EMPTY;\n    }), takeUntil(this._destroy$)).subscribe(() => this._invokeBootstrapOnStates(results.states));\n  }\n  _invokeInitOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsOnChanges) {\n        this._store.select(state => getValue(state, mappedStore.path)).pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$)).subscribe(([previousValue, currentValue]) => {\n          const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n          instance.ngxsOnChanges(change);\n        });\n      }\n      if (instance.ngxsOnInit) {\n        instance.ngxsOnInit(this._getStateContext(mappedStore));\n      }\n      mappedStore.isInitialised = true;\n    }\n  }\n  _invokeBootstrapOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsAfterBootstrap) {\n        instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n      }\n    }\n  }\n  _getStateContext(mappedStore) {\n    return this._stateContextFactory.createStateContext(mappedStore);\n  }\n}\n/** @nocollapse */\nLifecycleStateManager.ɵfac = function LifecycleStateManager_Factory(t) {\n  return new (t || LifecycleStateManager)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalErrorReporter), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(i5.NgxsBootstrapper));\n};\n/** @nocollapse */\nLifecycleStateManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LifecycleStateManager,\n  factory: LifecycleStateManager.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LifecycleStateManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: InternalErrorReporter\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: StateContextFactory\n    }, {\n      type: i5.NgxsBootstrapper\n    }];\n  }, null);\n})();\n\n/**\n * Root module\n * @ignore\n */\nclass NgxsRootModule {\n  constructor(factory, internalStateOperations, _store, _select, states = [], lifecycleStateManager) {\n    // Add stores to the state graph and return their defaults\n    const results = factory.addAndReturnDefaults(states);\n    internalStateOperations.setStateToTheCurrentWithNew(results);\n    // Connect our actions stream\n    factory.connectActionHandlers();\n    // Dispatch the init action and invoke init and bootstrap functions after\n    lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n  }\n}\n/** @nocollapse */\nNgxsRootModule.ɵfac = function NgxsRootModule_Factory(t) {\n  return new (t || NgxsRootModule)(i0.ɵɵinject(StateFactory), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(Store), i0.ɵɵinject(SelectFactory), i0.ɵɵinject(ROOT_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n};\n/** @nocollapse */\nNgxsRootModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsRootModule\n});\n/** @nocollapse */\nNgxsRootModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsRootModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: StateFactory\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: Store\n    }, {\n      type: SelectFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [ROOT_STATE_TOKEN]\n      }]\n    }, {\n      type: LifecycleStateManager\n    }];\n  }, null);\n})();\n\n/**\n * Feature module\n * @ignore\n */\nclass NgxsFeatureModule {\n  constructor(_store, internalStateOperations, factory, states = [], lifecycleStateManager) {\n    // Since FEATURE_STATE_TOKEN is a multi token, we need to\n    // flatten it [[Feature1State, Feature2State], [Feature3State]]\n    const flattenedStates = NgxsFeatureModule.flattenStates(states);\n    // add stores to the state graph and return their defaults\n    const results = factory.addAndReturnDefaults(flattenedStates);\n    if (results.states.length) {\n      internalStateOperations.setStateToTheCurrentWithNew(results);\n      // dispatch the update action and invoke init and bootstrap functions after\n      lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n    }\n  }\n  static flattenStates(states = []) {\n    return states.reduce((total, values) => total.concat(values), []);\n  }\n}\n/** @nocollapse */\nNgxsFeatureModule.ɵfac = function NgxsFeatureModule_Factory(t) {\n  return new (t || NgxsFeatureModule)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateFactory), i0.ɵɵinject(FEATURE_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n};\n/** @nocollapse */\nNgxsFeatureModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsFeatureModule\n});\n/** @nocollapse */\nNgxsFeatureModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsFeatureModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: StateFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FEATURE_STATE_TOKEN]\n      }]\n    }, {\n      type: LifecycleStateManager\n    }];\n  }, null);\n})();\n\n/**\n * Ngxs Module\n */\nclass NgxsModule {\n  /**\n   * Root module factory\n   */\n  static forRoot(states = [], options = {}) {\n    return {\n      ngModule: NgxsRootModule,\n      providers: [StateFactory, PluginManager, ...states, ...NgxsModule.ngxsTokenProviders(states, options)]\n    };\n  }\n  /**\n   * Feature module factory\n   */\n  static forFeature(states = []) {\n    return {\n      ngModule: NgxsFeatureModule,\n      providers: [\n      // This is required on the feature level, see comments in `state-factory.ts`.\n      StateFactory, PluginManager, ...states, {\n        provide: FEATURE_STATE_TOKEN,\n        multi: true,\n        useValue: states\n      }]\n    };\n  }\n  static ngxsTokenProviders(states, options) {\n    return [{\n      provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,\n      useValue: options.executionStrategy\n    }, {\n      provide: ROOT_STATE_TOKEN,\n      useValue: states\n    }, {\n      provide: ROOT_OPTIONS,\n      useValue: options\n    }, {\n      provide: APP_BOOTSTRAP_LISTENER,\n      useFactory: NgxsModule.appBootstrapListenerFactory,\n      multi: true,\n      deps: [NgxsBootstrapper]\n    }, {\n      provide: ɵNGXS_STATE_CONTEXT_FACTORY,\n      useExisting: StateContextFactory\n    }, {\n      provide: ɵNGXS_STATE_FACTORY,\n      useExisting: StateFactory\n    }];\n  }\n  static appBootstrapListenerFactory(bootstrapper) {\n    return () => bootstrapper.bootstrap();\n  }\n}\n/** @nocollapse */\nNgxsModule.ɵfac = function NgxsModule_Factory(t) {\n  return new (t || NgxsModule)();\n};\n/** @nocollapse */\nNgxsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsModule\n});\n/** @nocollapse */\nNgxsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\n/**\n * Decorates a method with a action information.\n */\nfunction Action(actions, options) {\n  return (target, name) => {\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const isStaticMethod = target.hasOwnProperty('prototype');\n      if (isStaticMethod) {\n        throwActionDecoratorError();\n      }\n    }\n    const meta = ensureStoreMetadata$1(target.constructor);\n    if (!Array.isArray(actions)) {\n      actions = [actions];\n    }\n    for (const action of actions) {\n      const type = action.type;\n      if (!meta.actions[type]) {\n        meta.actions[type] = [];\n      }\n      meta.actions[type].push({\n        fn: name,\n        options: options || {},\n        type\n      });\n    }\n  };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n  function getStateOptions(inheritedStateClass) {\n    const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};\n    return Object.assign(Object.assign({}, inheritanceOptions), options);\n  }\n  function mutateMetaData(params) {\n    const {\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    } = params;\n    const {\n      children,\n      defaults,\n      name\n    } = optionsWithInheritance;\n    const stateName = typeof name === 'string' ? name : name && name.getName() || null;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      StoreValidators.checkThatStateIsNamedCorrectly(stateName);\n    }\n    if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n      const inheritedMeta = inheritedStateClass[META_KEY] || {};\n      meta.actions = Object.assign(Object.assign({}, meta.actions), inheritedMeta.actions);\n    }\n    meta.children = children;\n    meta.defaults = defaults;\n    meta.name = stateName;\n  }\n  return target => {\n    const stateClass = target;\n    const meta = ensureStoreMetadata$1(stateClass);\n    const inheritedStateClass = Object.getPrototypeOf(stateClass);\n    const optionsWithInheritance = getStateOptions(inheritedStateClass);\n    mutateMetaData({\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    });\n    stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n  };\n}\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n  if (!SelectFactory.store) {\n    throwSelectFactoryNotConnectedError();\n  }\n  return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n  rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n  if (typeof rawSelector === 'string') {\n    const propsArray = paths.length ? [rawSelector, ...paths] : rawSelector.split('.');\n    return propGetter(propsArray, SelectFactory.config);\n  }\n  return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n  const lastCharIndex = name.length - 1;\n  const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n */\nfunction Select(rawSelector, ...paths) {\n  return function (target, key) {\n    const name = key.toString();\n    const selectorId = `__${name}__selector`;\n    const selector = createSelectorFn(name, rawSelector, paths);\n    Object.defineProperties(target, {\n      [selectorId]: {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      },\n      [name]: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n        }\n      }\n    });\n  };\n}\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n  getOptions: target => {\n    return target && target[SELECTOR_OPTIONS_META_KEY] || {};\n  },\n  defineOptions: (target, options) => {\n    if (!target) return;\n    target[SELECTOR_OPTIONS_META_KEY] = options;\n  }\n};\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n  const selectorMetaData = ensureSelectorMetadata$1(originalFn);\n  selectorMetaData.originalFn = originalFn;\n  let getExplicitSelectorOptions = () => ({});\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName || null;\n    getExplicitSelectorOptions = creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n  }\n  const selectorMetaDataClone = Object.assign({}, selectorMetaData);\n  selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n  return selectorMetaData;\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}), selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}), selectorMetaData.getSelectorOptions() || {}), explicitOptions);\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n  return function decorate(target, methodName, descriptor) {\n    if (methodName) {\n      descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, methodName));\n      // Method Decorator\n      const originalFn = descriptor.value || descriptor.originalFn;\n      if (originalFn) {\n        selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n      }\n    } else {\n      // Class Decorator\n      selectorOptionsMetaAccessor.defineOptions(target, options);\n    }\n  };\n}\nfunction ensureStoreMetadata(target) {\n  return ensureStoreMetadata$1(target);\n}\nfunction getStoreMetadata(target) {\n  return getStoreMetadata$1(target);\n}\nfunction ensureSelectorMetadata(target) {\n  return ensureSelectorMetadata$1(target);\n}\nfunction getSelectorMetadata(target) {\n  return getSelectorMetadata$1(target);\n}\nfunction createSelector(selectors, projector, creationMetadata) {\n  const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);\n  const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);\n  selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);\n  return memoizedFn;\n}\nfunction Selector(selectors) {\n  return (target, key, descriptor) => {\n    descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, key));\n    const originalFn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (originalFn && typeof originalFn !== 'function') {\n        throwSelectorDecoratorError();\n      }\n    }\n    const memoizedFn = createSelector(selectors, originalFn, {\n      containerClass: target,\n      selectorName: key.toString(),\n      getSelectorOptions() {\n        return {};\n      }\n    });\n    const newDescriptor = {\n      configurable: true,\n      get() {\n        return memoizedFn;\n      }\n    };\n    // Add hidden property to descriptor\n    newDescriptor['originalFn'] = originalFn;\n    return newDescriptor;\n  };\n}\nclass StateToken {\n  constructor(name) {\n    this.name = name;\n    const selectorMetadata = ensureSelectorMetadata$1(this);\n    selectorMetadata.makeRootSelector = runtimeContext => {\n      return runtimeContext.getStateGetter(this.name);\n    };\n  }\n  getName() {\n    return this.name;\n  }\n  toString() {\n    return `StateToken[${this.name}]`;\n  }\n}\nclass NgxsDevelopmentModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsDevelopmentModule,\n      providers: [NgxsUnhandledActionsLogger, {\n        provide: NGXS_DEVELOPMENT_OPTIONS,\n        useValue: options\n      }]\n    };\n  }\n}\n/** @nocollapse */\nNgxsDevelopmentModule.ɵfac = function NgxsDevelopmentModule_Factory(t) {\n  return new (t || NgxsDevelopmentModule)();\n};\n/** @nocollapse */\nNgxsDevelopmentModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsDevelopmentModule\n});\n/** @nocollapse */\nNgxsDevelopmentModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsDevelopmentModule, [{\n    type: NgModule\n  }], null, null);\n})();\nfunction ensureValidSelector(selector, context = {}) {\n  const noun = context.noun || 'selector';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  ensureValueProvided(selector, {\n    noun,\n    prefix: context.prefix\n  });\n  const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n  if (!metadata) {\n    throw new Error(`${prefix}The value provided as the ${noun} is not a valid selector.`);\n  }\n}\nfunction ensureValueProvided(value, context = {}) {\n  const noun = context.noun || 'value';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  if (!value) {\n    throw new Error(`${prefix}A ${noun} must be provided.`);\n  }\n}\nfunction createModelSelector(selectorMap) {\n  const selectorKeys = Object.keys(selectorMap);\n  const selectors = Object.values(selectorMap);\n  ensureValidSelectorMap({\n    prefix: '[createModelSelector]',\n    selectorMap,\n    selectorKeys,\n    selectors\n  });\n  return createSelector(selectors, (...args) => {\n    return selectorKeys.reduce((obj, key, index) => {\n      obj[key] = args[index];\n      return obj;\n    }, {});\n  });\n}\nfunction ensureValidSelectorMap({\n  prefix,\n  selectorMap,\n  selectorKeys,\n  selectors\n}) {\n  ensureValueProvided(selectorMap, {\n    prefix,\n    noun: 'selector map'\n  });\n  ensureValueProvided(typeof selectorMap === 'object', {\n    prefix,\n    noun: 'valid selector map'\n  });\n  ensureValueProvided(selectorKeys.length, {\n    prefix,\n    noun: 'non-empty selector map'\n  });\n  selectors.forEach((selector, index) => ensureValidSelector(selector, {\n    prefix,\n    noun: `selector for the '${selectorKeys[index]}' property`\n  }));\n}\nfunction createPickSelector(selector, keys) {\n  ensureValidSelector(selector, {\n    prefix: '[createPickSelector]'\n  });\n  const validKeys = keys.filter(Boolean);\n  const selectors = validKeys.map(key => createSelector([selector], s => s[key]));\n  return createSelector([...selectors], (...props) => {\n    return validKeys.reduce((acc, key, index) => {\n      acc[key] = props[index];\n      return acc;\n    }, {});\n  });\n}\nfunction createPropertySelectors(parentSelector) {\n  ensureValidSelector(parentSelector, {\n    prefix: '[createPropertySelectors]',\n    noun: 'parent selector'\n  });\n  const cache = {};\n  return new Proxy({}, {\n    get(_target, prop) {\n      const selector = cache[prop] || createSelector([parentSelector], s => s === null || s === void 0 ? void 0 : s[prop]);\n      cache[prop] = selector;\n      return selector;\n    }\n  });\n}\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, Actions, InitState, NGXS_PLUGINS, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, StateStream, StateToken, Store, UpdateState, actionMatcher, createModelSelector, createPickSelector, createPropertySelectors, createSelector, ensureSelectorMetadata, ensureStoreMetadata, getActionTypeFromInstance, getSelectorMetadata, getStoreMetadata, getValue, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, setValue, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule };","map":{"version":3,"names":["i0","NgZone","PLATFORM_ID","Injectable","Inject","InjectionToken","inject","INJECTOR","ɵglobal","ErrorHandler","Optional","SkipSelf","NgModule","APP_BOOTSTRAP_LISTENER","i5","memoize","INITIAL_STATE_TOKEN","NgxsBootstrapper","ɵNGXS_STATE_CONTEXT_FACTORY","ɵNGXS_STATE_FACTORY","isPlatformServer","Observable","Subject","BehaviorSubject","of","forkJoin","throwError","EMPTY","from","isObservable","filter","map","share","shareReplay","take","exhaustMap","mergeMap","defaultIfEmpty","catchError","takeUntil","distinctUntilChanged","tap","startWith","pairwise","getActionTypeFromInstance","action","constructor","type","actionMatcher","action1","type1","action2","setValue","obj","prop","val","Object","assign","split","lastIndex","length","reduce","acc","part","index","Array","isArray","slice","getValue","isObject$1","item","mergeDeep","base","sources","source","shift","key","throwStateNameError","name","Error","throwStateNamePropertyError","throwStateUniqueError","current","newName","oldName","throwStateDecoratorError","throwActionDecoratorError","throwSelectorDecoratorError","getZoneWarningMessage","getUndecoratedStateInIvyWarningMessage","throwSelectFactoryNotConnectedError","throwPatchingArrayError","throwPatchingPrimitiveError","DispatchOutsideZoneNgxsExecutionStrategy","_ngZone","_platformId","ngDevMode","verifyZoneIsNotNooped","enter","func","runInsideAngular","runOutsideAngular","leave","isInAngularZone","run","ɵfac","DispatchOutsideZoneNgxsExecutionStrategy_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ɵsetClassMetadata","args","undefined","decorators","ngZone","console","warn","ROOT_OPTIONS","ROOT_STATE_TOKEN","FEATURE_STATE_TOKEN","NGXS_PLUGINS","META_KEY","META_OPTIONS_KEY","SELECTOR_META_KEY","NgxsConfig","defaultsState","selectorOptions","injectContainerState","suppressErrors","compatibility","strictContentSecurityPolicy","executionStrategy","NgxsConfig_Factory","r","options","useFactory","deps","NgxsSimpleChange","previousValue","currentValue","firstChange","NoopNgxsExecutionStrategy","NoopNgxsExecutionStrategy_Factory","USER_PROVIDED_NGXS_EXECUTION_STRATEGY","NGXS_EXECUTION_STRATEGY","injector","get","Zone","ensureStoreMetadata$1","target","hasOwnProperty","defaultMetadata","actions","defaults","path","makeRootSelector","context","getStateGetter","children","defineProperty","value","getStoreMetadata$1","ensureSelectorMetadata$1","originalFn","containerClass","selectorName","getSelectorOptions","getSelectorMetadata$1","compliantPropGetter","paths","copyOfPaths","fastPropGetter","segments","seg","i","l","expr","fn","Function","propGetter","config","buildGraph","stateClasses","findName","stateClass","meta","find","g","result","nameToState","states","findFullParentPath","newObj","visit","child","keyToFind","indexOf","parent","topologicalSort","graph","sorted","visited","ancestors","push","forEach","dep","join","keys","k","reverse","isObject","ofAction","allowedTypes","ofActionOperator","ofActionDispatched","ofActionSuccessful","ofActionCanceled","ofActionCompleted","allowedStatuses","mapActionResult","ofActionErrored","statuses","mapOperator","mapAction","allowedMap","createAllowedActionTypesMap","allowedStatusMap","createAllowedStatusesMap","o","pipe","filterStatus","ctx","actionType","typeMatch","statusMatch","status","error","successful","canceled","types","filterMap","klass","leaveNgxs","ngxsExecutionStrategy","sink","subscribe","next","complete","InternalNgxsExecutionStrategy","_executionStrategy","InternalNgxsExecutionStrategy_Factory","orderedQueueOperation","operation","callsQueue","busyPushingNext","callOperation","unshift","nextCallArgs","pop","OrderedSubject","arguments","_orderedNext","OrderedBehaviorSubject","_currentValue","InternalActions","ngOnDestroy","ɵInternalActions_BaseFactory","InternalActions_Factory","ɵɵgetInheritedFactory","Actions","internalActions$","internalExecutionStrategy","sharedInternalActions$","observer","childSubscription","add","Actions_Factory","compose","funcs","curr","nextArgs","ngxsErrorHandler","internalErrorReporter","subscribed","Promise","resolve","then","reportErrorSafely","subscriber","InternalErrorReporter","_injector","_errorHandler","handleError","_a","InternalErrorReporter_Factory","Injector","StateStream","StateStream_Factory","PluginManager","_parentManager","_pluginHandlers","plugins","registerHandlers","rootPlugins","pluginHandlers","getPluginHandlers","handlers","plugin","handle","bind","PluginManager_Factory","InternalDispatchedActionResults","ɵInternalDispatchedActionResults_BaseFactory","InternalDispatchedActionResults_Factory","InternalDispatcher","_actions","_actionResults","_pluginManager","_stateStream","_ngxsExecutionStrategy","_internalErrorReporter","dispatch","actionOrActions","dispatchByEvents","dispatchSingle","prevState","nextState","nextAction","actionResult$","getActionResultStream","createDispatchObservable","InternalDispatcher_Factory","deepFreeze","freeze","oIsFunction","hasOwnProp","prototype","getOwnPropertyNames","call","isFrozen","InternalStateOperations","_dispatcher","_config","getRootStateOperations","rootStateOperations","getState","setState","newState","developmentMode","ensureStateAndActionsAreImmutable","setStateToTheCurrentWithNew","results","stateOperations","currentState","InternalStateOperations_Factory","root","frozenValue","simplePatch","existingState","StateContextFactory","_internalStateOperations","createStateContext","mappedStore","currentAppState","setStateValue","newValue","newAppState","setStateFromOperator","stateOperator","local","isStateOperator","patchState","patchOperator","StateContextFactory_Factory","StoreValidators","checkThatStateIsNamedCorrectly","stateNameRegex","test","checkThatStateNameIsUnique","stateName","state","statesByName","checkThatStateClassesHaveBeenDecorated","RegExp","ensureStateClassIsInjectable","jit_hasInjectableAnnotation","aot_hasNgInjectableDef","annotations","__annotations__","some","annotation","ngMetadataName","InitState","UpdateState","addedStates","NGXS_DEVELOPMENT_OPTIONS","warnOnUnhandledActions","NgxsUnhandledActionsLogger","_ignoredActions","Set","ignoreActions","ignore","actionShouldBeIgnored","NgxsUnhandledActionsLogger_Factory","NG_DEV_MODE","StateFactory","_parentFactory","_stateContextFactory","_initialState","_actionsSubscription","_states","_statesByName","_statePaths","getRuntimeSelectorContext","stateFactory","resolveGetter","statePaths","getter","localOptions","globalSelectorOptions","cloneDefaults","unsubscribe","newStates","addToStatesMap","stateGraph","sortedStates","nameGraph","bootstrappedStores","addRuntimeInfoToMeta","stateMap","isInitialised","instance","hasBeenMountedAndBootstrapped","addAndReturnDefaults","classes","mappedStores","connectActionHandlers","dispatched$","invokeActions","actionHasBeenHandled","metadata","actionMetas","actionMeta","stateContext","cancelUncompleted","e","unhandledActionsLogger","statesMap","unmountedState","valueIsBootstrappedInInitialState","StateFactory_Factory","createRootSelectorFactory","selectorMetaData","selectors","memoizedSelectorFn","argumentSelectorFunctions","getRuntimeSelectorInfo","selectFromRoot","rootState","argFn","ex","TypeError","createMemoizedSelectorFn","creationMetadata","wrappedFn","wrappedSelectorFn","returnValue","apply","innerMemoizedFn","memoizedFn","setPrototypeOf","localSelectorOptions","selectorsToApply","getSelectorsToApply","selector","getRootSelectorFactory","canInjectContainerState","Store","_internalExecutionStrategy","_stateFactory","initialStateValue","_selectableStateStream","bufferSize","refCount","initStateStream","select","selectorFn","getStoreBoundSelectorFn","err","selectOnce","selectSnapshot","snapshot","reset","makeSelectorFn","runtimeContext","storeIsEmpty","defaultStateNotEmpty","storeValues","Store_Factory","SelectFactory","store","SelectFactory_Factory","LifecycleStateManager","_store","_bootstrapper","_destroy$","ngxsBootstrap","_invokeInitOnStates","appBootstrapped$","appBootstrapped","_invokeBootstrapOnStates","ngxsOnChanges","change","ngxsOnInit","_getStateContext","ngxsAfterBootstrap","LifecycleStateManager_Factory","NgxsRootModule","internalStateOperations","_select","lifecycleStateManager","NgxsRootModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","NgxsFeatureModule","flattenedStates","flattenStates","total","values","concat","NgxsFeatureModule_Factory","NgxsModule","forRoot","ngModule","providers","ngxsTokenProviders","forFeature","provide","multi","useValue","appBootstrapListenerFactory","useExisting","bootstrapper","bootstrap","NgxsModule_Factory","Action","isStaticMethod","State","getStateOptions","inheritedStateClass","inheritanceOptions","mutateMetaData","params","optionsWithInheritance","getName","inheritedMeta","getPrototypeOf","DOLLAR_CHAR_CODE","createSelectObservable","createSelectorFn","rawSelector","removeDollarAtTheEnd","propsArray","lastCharIndex","dollarAtTheEnd","charCodeAt","Select","toString","selectorId","defineProperties","writable","enumerable","configurable","SELECTOR_OPTIONS_META_KEY","selectorOptionsMetaAccessor","getOptions","defineOptions","setupSelectorMetadata","getExplicitSelectorOptions","selectorMetaDataClone","getLocalSelectorOptions","explicitOptions","SelectorOptions","decorate","methodName","descriptor","getOwnPropertyDescriptor","ensureStoreMetadata","getStoreMetadata","ensureSelectorMetadata","getSelectorMetadata","createSelector","projector","Selector","newDescriptor","StateToken","selectorMetadata","NgxsDevelopmentModule","NgxsDevelopmentModule_Factory","ensureValidSelector","noun","prefix","ensureValueProvided","createModelSelector","selectorMap","selectorKeys","ensureValidSelectorMap","createPickSelector","validKeys","Boolean","s","props","createPropertySelectors","parentSelector","cache","Proxy","_target","ɵNgxsFeatureModule","ɵNgxsRootModule"],"sources":["/Users/chamalsha/Desktop/mobile-web-practice/node_modules/@ngxs/store/fesm2015/ngxs-store.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { NgZone, PLATFORM_ID, Injectable, Inject, InjectionToken, inject, INJECTOR, ɵglobal, ErrorHandler, Optional, SkipSelf, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport * as i5 from '@ngxs/store/internals';\nimport { memoize, INITIAL_STATE_TOKEN, NgxsBootstrapper, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subject, BehaviorSubject, of, forkJoin, throwError, EMPTY, from, isObservable } from 'rxjs';\nimport { filter, map, share, shareReplay, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, distinctUntilChanged, tap, startWith, pairwise } from 'rxjs/operators';\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n    if (action.constructor && action.constructor.type) {\n        return action.constructor.type;\n    }\n    else {\n        return action.type;\n    }\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n    const type1 = getActionTypeFromInstance(action1);\n    return function (action2) {\n        return type1 === getActionTypeFromInstance(action2);\n    };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n    obj = Object.assign({}, obj);\n    const split = prop.split('.');\n    const lastIndex = split.length - 1;\n    split.reduce((acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n        }\n        return acc && acc[part];\n    }, obj);\n    return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);\n/**\n * Simple object check.\n *\n *    isObject({a:1}) //=> true\n *    isObject(1) //=> false\n *\n * @ignore\n */\nconst isObject$1 = (item) => {\n    return item && typeof item === 'object' && !Array.isArray(item);\n};\n/**\n * Deep merge two objects.\n *\n *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}\n *\n * @param base base object onto which `sources` will be applied\n */\nconst mergeDeep = (base, ...sources) => {\n    if (!sources.length)\n        return base;\n    const source = sources.shift();\n    if (isObject$1(base) && isObject$1(source)) {\n        for (const key in source) {\n            if (isObject$1(source[key])) {\n                if (!base[key])\n                    Object.assign(base, { [key]: {} });\n                mergeDeep(base[key], source[key]);\n            }\n            else {\n                Object.assign(base, { [key]: source[key] });\n            }\n        }\n    }\n    return mergeDeep(base, ...sources);\n};\n\nfunction throwStateNameError(name) {\n    throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n    throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n    throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n    throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n    throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n    throw new Error('Selectors only work on methods.');\n}\nfunction getZoneWarningMessage() {\n    return ('Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' +\n        'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' +\n        'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })');\n}\nfunction getUndecoratedStateInIvyWarningMessage(name) {\n    return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction throwSelectFactoryNotConnectedError() {\n    throw new Error('You have forgotten to import the NGXS module!');\n}\nfunction throwPatchingArrayError() {\n    throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n    throw new Error('Patching primitives is not supported.');\n}\n\nclass DispatchOutsideZoneNgxsExecutionStrategy {\n    constructor(_ngZone, _platformId) {\n        this._ngZone = _ngZone;\n        this._platformId = _platformId;\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            verifyZoneIsNotNooped(_ngZone);\n        }\n    }\n    enter(func) {\n        if (isPlatformServer(this._platformId)) {\n            return this.runInsideAngular(func);\n        }\n        return this.runOutsideAngular(func);\n    }\n    leave(func) {\n        return this.runInsideAngular(func);\n    }\n    runInsideAngular(func) {\n        if (NgZone.isInAngularZone()) {\n            return func();\n        }\n        return this._ngZone.run(func);\n    }\n    runOutsideAngular(func) {\n        if (NgZone.isInAngularZone()) {\n            return this._ngZone.runOutsideAngular(func);\n        }\n        return func();\n    }\n}\n/** @nocollapse */ DispatchOutsideZoneNgxsExecutionStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: DispatchOutsideZoneNgxsExecutionStrategy, deps: [{ token: i0.NgZone }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ DispatchOutsideZoneNgxsExecutionStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: DispatchOutsideZoneNgxsExecutionStrategy, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: DispatchOutsideZoneNgxsExecutionStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; } });\n// Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\nfunction verifyZoneIsNotNooped(ngZone) {\n    // `NoopNgZone` is not exposed publicly as it doesn't expect\n    // to be used outside of the core Angular code, thus we just have\n    // to check if the zone doesn't extend or instanceof `NgZone`.\n    if (ngZone instanceof NgZone) {\n        return;\n    }\n    console.warn(getZoneWarningMessage());\n}\n\nconst ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\nconst ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');\nconst FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');\nconst NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nconst META_KEY = 'NGXS_META';\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nconst SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n/**\n * The NGXS config settings.\n */\nclass NgxsConfig {\n    constructor() {\n        /**\n         * Defining the default state before module initialization\n         * This is convenient if we need to create a define our own set of states.\n         * @deprecated will be removed after v4\n         * (default: {})\n         */\n        this.defaultsState = {};\n        /**\n         * Defining shared selector options\n         */\n        this.selectorOptions = {\n            injectContainerState: true,\n            suppressErrors: true // TODO: default is true in v3, will change in v4\n        };\n        this.compatibility = {\n            strictContentSecurityPolicy: false\n        };\n        this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n    }\n}\n/** @nocollapse */ NgxsConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NgxsConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsConfig, providedIn: 'root', useFactory: (options) => mergeDeep(new NgxsConfig(), options), deps: [{ token: ROOT_OPTIONS }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsConfig, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                    useFactory: (options) => mergeDeep(new NgxsConfig(), options),\n                    deps: [ROOT_OPTIONS]\n                }]\n        }], ctorParameters: function () { return []; } });\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n    constructor(previousValue, currentValue, firstChange) {\n        this.previousValue = previousValue;\n        this.currentValue = currentValue;\n        this.firstChange = firstChange;\n    }\n}\n\nclass NoopNgxsExecutionStrategy {\n    enter(func) {\n        return func();\n    }\n    leave(func) {\n        return func();\n    }\n}\n/** @nocollapse */ NoopNgxsExecutionStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NoopNgxsExecutionStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NoopNgxsExecutionStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NoopNgxsExecutionStrategy, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NoopNgxsExecutionStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * The strategy that might be provided by users through `options.executionStrategy`.\n */\nconst USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');\n/*\n * Internal execution strategy injection token\n */\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY', {\n    providedIn: 'root',\n    factory: () => {\n        const injector = inject(INJECTOR);\n        const executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);\n        return executionStrategy\n            ? injector.get(executionStrategy)\n            : injector.get(typeof ɵglobal.Zone !== 'undefined'\n                ? DispatchOutsideZoneNgxsExecutionStrategy\n                : NoopNgxsExecutionStrategy);\n    }\n});\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ensureStoreMetadata$1(target) {\n    if (!target.hasOwnProperty(META_KEY)) {\n        const defaultMetadata = {\n            name: null,\n            actions: {},\n            defaults: {},\n            path: null,\n            makeRootSelector(context) {\n                return context.getStateGetter(defaultMetadata.name);\n            },\n            children: []\n        };\n        Object.defineProperty(target, META_KEY, { value: defaultMetadata });\n    }\n    return getStoreMetadata$1(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction getStoreMetadata$1(target) {\n    return target[META_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ensureSelectorMetadata$1(target) {\n    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n        const defaultMetadata = {\n            makeRootSelector: null,\n            originalFn: null,\n            containerClass: null,\n            selectorName: null,\n            getSelectorOptions: () => ({})\n        };\n        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });\n    }\n    return getSelectorMetadata$1(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction getSelectorMetadata$1(target) {\n    return target[SELECTOR_META_KEY];\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n    const copyOfPaths = paths.slice();\n    return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n    const segments = paths;\n    let seg = 'store.' + segments[0];\n    let i = 0;\n    const l = segments.length;\n    let expr = seg;\n    while (++i < l) {\n        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n    }\n    const fn = new Function('store', 'return ' + expr + ';');\n    return fn;\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nfunction propGetter(paths, config) {\n    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n        return compliantPropGetter(paths);\n    }\n    else {\n        return fastPropGetter(paths);\n    }\n}\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n    const findName = (stateClass) => {\n        const meta = stateClasses.find(g => g === stateClass);\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {\n            throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n        }\n        return meta[META_KEY].name;\n    };\n    return stateClasses.reduce((result, stateClass) => {\n        const { name, children } = stateClass[META_KEY];\n        result[name] = (children || []).map(findName);\n        return result;\n    }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n    return states.reduce((result, stateClass) => {\n        const meta = stateClass[META_KEY];\n        result[meta.name] = stateClass;\n        return result;\n    }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, newObj = {}) {\n    const visit = (child, keyToFind) => {\n        for (const key in child) {\n            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n                const parent = visit(child, key);\n                return parent !== null ? `${parent}.${key}` : key;\n            }\n        }\n        return null;\n    };\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            const parent = visit(obj, key);\n            newObj[key] = parent ? `${parent}.${key}` : key;\n        }\n    }\n    return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n    const sorted = [];\n    const visited = {};\n    const visit = (name, ancestors = []) => {\n        if (!Array.isArray(ancestors)) {\n            ancestors = [];\n        }\n        ancestors.push(name);\n        visited[name] = true;\n        graph[name].forEach((dep) => {\n            // Caretaker note: we have still left the `typeof` condition in order to avoid\n            // creating a breaking change for projects that still use the View Engine.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {\n                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n            }\n            if (visited[dep]) {\n                return;\n            }\n            visit(dep, ancestors.slice(0));\n        });\n        if (sorted.indexOf(name) < 0) {\n            sorted.push(name);\n        }\n    };\n    Object.keys(graph).forEach(k => visit(k));\n    return sorted.reverse();\n}\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\nfunction isObject(obj) {\n    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n    return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"DISPATCHED\" /* Dispatched */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"SUCCESSFUL\" /* Successful */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"CANCELED\" /* Canceled */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n    const allowedStatuses = [\n        \"SUCCESSFUL\" /* Successful */,\n        \"CANCELED\" /* Canceled */,\n        \"ERRORED\" /* Errored */\n    ];\n    return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"ERRORED\" /* Errored */]);\n}\nfunction ofActionOperator(allowedTypes, statuses, \n// This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,\n// since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`\n// defaults to `any`, thus there is no sense from union type.\nmapOperator = mapAction) {\n    const allowedMap = createAllowedActionTypesMap(allowedTypes);\n    const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n    return function (o) {\n        return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n    };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n    return filter((ctx) => {\n        const actionType = getActionTypeFromInstance(ctx.action);\n        const typeMatch = allowedTypes[actionType];\n        const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n        return typeMatch && statusMatch;\n    });\n}\nfunction mapActionResult() {\n    return map(({ action, status, error }) => {\n        return {\n            action,\n            result: {\n                successful: \"SUCCESSFUL\" /* Successful */ === status,\n                canceled: \"CANCELED\" /* Canceled */ === status,\n                error\n            }\n        };\n    });\n}\nfunction mapAction() {\n    return map((ctx) => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n    return types.reduce((filterMap, klass) => {\n        filterMap[getActionTypeFromInstance(klass)] = true;\n        return filterMap;\n    }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n    return statuses.reduce((filterMap, status) => {\n        filterMap[status] = true;\n        return filterMap;\n    }, {});\n}\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n    return (source) => {\n        return new Observable((sink) => {\n            return source.subscribe({\n                next(value) {\n                    ngxsExecutionStrategy.leave(() => sink.next(value));\n                },\n                error(error) {\n                    ngxsExecutionStrategy.leave(() => sink.error(error));\n                },\n                complete() {\n                    ngxsExecutionStrategy.leave(() => sink.complete());\n                }\n            });\n        });\n    };\n}\n\nclass InternalNgxsExecutionStrategy {\n    constructor(_executionStrategy) {\n        this._executionStrategy = _executionStrategy;\n    }\n    enter(func) {\n        return this._executionStrategy.enter(func);\n    }\n    leave(func) {\n        return this._executionStrategy.leave(func);\n    }\n}\n/** @nocollapse */ InternalNgxsExecutionStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalNgxsExecutionStrategy, deps: [{ token: NGXS_EXECUTION_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalNgxsExecutionStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalNgxsExecutionStrategy, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalNgxsExecutionStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXS_EXECUTION_STRATEGY]\n                }] }]; } });\n\n/**\n * This wraps the provided function, and will enforce the following:\n * - The calls will execute in the order that they are made\n * - A call will only be initiated when the previous call has completed\n * - If there is a call currently executing then the new call will be added\n *   to the queue and the function will return immediately\n *\n * NOTE: The following assumptions about the operation must hold true:\n * - The operation is synchronous in nature\n * - If any asynchronous side effects of the call exist, it should not\n *   have any bearing on the correctness of the next call in the queue\n * - The operation has a void return\n * - The caller should not assume that the call has completed upon\n *   return of the function\n * - The caller can assume that all the queued calls will complete\n *   within the current microtask\n * - The only way that a call will encounter another call in the queue\n *   would be if the call at the front of the queue initiated this call\n *   as part of its synchronous execution\n */\nfunction orderedQueueOperation(operation) {\n    const callsQueue = [];\n    let busyPushingNext = false;\n    return function callOperation(...args) {\n        if (busyPushingNext) {\n            callsQueue.unshift(args);\n            return;\n        }\n        busyPushingNext = true;\n        operation(...args);\n        while (callsQueue.length > 0) {\n            const nextCallArgs = callsQueue.pop();\n            nextCallArgs && operation(...nextCallArgs);\n        }\n        busyPushingNext = false;\n    };\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedSubject extends Subject {\n    constructor() {\n        super(...arguments);\n        this._orderedNext = orderedQueueOperation((value) => super.next(value));\n    }\n    next(value) {\n        this._orderedNext(value);\n    }\n}\n/**\n * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard BehaviorSubject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new BehaviorSubject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedBehaviorSubject extends BehaviorSubject {\n    constructor(value) {\n        super(value);\n        this._orderedNext = orderedQueueOperation((value) => super.next(value));\n        this._currentValue = value;\n    }\n    getValue() {\n        return this._currentValue;\n    }\n    next(value) {\n        this._currentValue = value;\n        this._orderedNext(value);\n    }\n}\n\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nclass InternalActions extends OrderedSubject {\n    ngOnDestroy() {\n        this.complete();\n    }\n}\n/** @nocollapse */ InternalActions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalActions, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalActions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalActions, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalActions, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nclass Actions extends Observable {\n    constructor(internalActions$, internalExecutionStrategy) {\n        const sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy), \n        // The `InternalActions` subject emits outside of the Angular zone.\n        // We have to re-enter the Angular zone for any incoming consumer.\n        // The `share()` operator reduces the number of change detections.\n        // This would call leave only once for any stream emission across all active subscribers.\n        share());\n        super(observer => {\n            const childSubscription = sharedInternalActions$.subscribe({\n                next: ctx => observer.next(ctx),\n                error: error => observer.error(error),\n                complete: () => observer.complete()\n            });\n            observer.add(childSubscription);\n        });\n    }\n}\n/** @nocollapse */ Actions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Actions, deps: [{ token: InternalActions }, { token: InternalNgxsExecutionStrategy }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ Actions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Actions, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Actions, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: InternalActions }, { type: InternalNgxsExecutionStrategy }]; } });\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nconst compose = (funcs) => (...args) => {\n    const curr = funcs.shift();\n    return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n\n/**\n * This operator is used for piping the observable result\n * from the `dispatch()`. It has a \"smart\" error handling\n * strategy that allows us to decide whether we propagate\n * errors to Angular's `ErrorHandler` or enable users to\n * handle them manually. We consider following cases:\n * 1) `store.dispatch()` (no subscribe) -> call `handleError()`\n * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`\n * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`\n * 4) `toPromise()` without `catch` -> do `handleError()`\n * 5) `toPromise()` with `catch` -> don't `handleError()`\n */\nfunction ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {\n    return (source) => {\n        let subscribed = false;\n        source.subscribe({\n            error: error => {\n                // Do not trigger change detection for a microtask. This depends on the execution\n                // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`\n                // leaves the Angular zone.\n                ngxsExecutionStrategy.enter(() => Promise.resolve().then(() => {\n                    if (!subscribed) {\n                        ngxsExecutionStrategy.leave(() => internalErrorReporter.reportErrorSafely(error));\n                    }\n                }));\n            }\n        });\n        return new Observable(subscriber => {\n            subscribed = true;\n            return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);\n        });\n    };\n}\nclass InternalErrorReporter {\n    constructor(_injector) {\n        this._injector = _injector;\n        /** Will be set lazily to be backward compatible. */\n        this._errorHandler = null;\n    }\n    reportErrorSafely(error) {\n        if (this._errorHandler === null) {\n            this._errorHandler = this._injector.get(ErrorHandler);\n        }\n        // The `try-catch` is used to avoid handling the error twice. Suppose we call\n        // `handleError` which re-throws the error internally. The re-thrown error will\n        // be caught by zone.js which will then get to the `zone.onError.emit()` and the\n        // `onError` subscriber will call `handleError` again.\n        try {\n            this._errorHandler.handleError(error);\n        }\n        catch (_a) { }\n    }\n}\n/** @nocollapse */ InternalErrorReporter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalErrorReporter, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalErrorReporter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalErrorReporter, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalErrorReporter, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nclass StateStream extends OrderedBehaviorSubject {\n    constructor() {\n        super({});\n    }\n    ngOnDestroy() {\n        // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.\n        // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users\n        // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.\n        this.complete();\n    }\n}\n/** @nocollapse */ StateStream.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateStream, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ StateStream.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateStream, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateStream, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return []; } });\n\nclass PluginManager {\n    constructor(_parentManager, _pluginHandlers) {\n        this._parentManager = _parentManager;\n        this._pluginHandlers = _pluginHandlers;\n        this.plugins = [];\n        this.registerHandlers();\n    }\n    get rootPlugins() {\n        return (this._parentManager && this._parentManager.plugins) || this.plugins;\n    }\n    registerHandlers() {\n        const pluginHandlers = this.getPluginHandlers();\n        this.rootPlugins.push(...pluginHandlers);\n    }\n    getPluginHandlers() {\n        const handlers = this._pluginHandlers || [];\n        return handlers.map((plugin) => (plugin.handle ? plugin.handle.bind(plugin) : plugin));\n    }\n}\n/** @nocollapse */ PluginManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: PluginManager, deps: [{ token: PluginManager, optional: true, skipSelf: true }, { token: NGXS_PLUGINS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ PluginManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: PluginManager });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: PluginManager, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: PluginManager, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXS_PLUGINS]\n                }, {\n                    type: Optional\n                }] }]; } });\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nclass InternalDispatchedActionResults extends Subject {\n}\n/** @nocollapse */ InternalDispatchedActionResults.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatchedActionResults, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalDispatchedActionResults.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatchedActionResults, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatchedActionResults, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\nclass InternalDispatcher {\n    constructor(_actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy, _internalErrorReporter) {\n        this._actions = _actions;\n        this._actionResults = _actionResults;\n        this._pluginManager = _pluginManager;\n        this._stateStream = _stateStream;\n        this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n        this._internalErrorReporter = _internalErrorReporter;\n    }\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions) {\n        const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n        return result.pipe(ngxsErrorHandler(this._internalErrorReporter, this._ngxsExecutionStrategy));\n    }\n    dispatchByEvents(actionOrActions) {\n        if (Array.isArray(actionOrActions)) {\n            if (actionOrActions.length === 0)\n                return of(this._stateStream.getValue());\n            return forkJoin(actionOrActions.map(action => this.dispatchSingle(action)));\n        }\n        else {\n            return this.dispatchSingle(actionOrActions);\n        }\n    }\n    dispatchSingle(action) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const type = getActionTypeFromInstance(action);\n            if (!type) {\n                const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n                return throwError(error);\n            }\n        }\n        const prevState = this._stateStream.getValue();\n        const plugins = this._pluginManager.plugins;\n        return compose([\n            ...plugins,\n            (nextState, nextAction) => {\n                if (nextState !== prevState) {\n                    this._stateStream.next(nextState);\n                }\n                const actionResult$ = this.getActionResultStream(nextAction);\n                actionResult$.subscribe(ctx => this._actions.next(ctx));\n                this._actions.next({ action: nextAction, status: \"DISPATCHED\" /* Dispatched */ });\n                return this.createDispatchObservable(actionResult$);\n            }\n        ])(prevState, action).pipe(shareReplay());\n    }\n    getActionResultStream(action) {\n        return this._actionResults.pipe(filter((ctx) => ctx.action === action && ctx.status !== \"DISPATCHED\" /* Dispatched */), take(1), shareReplay());\n    }\n    createDispatchObservable(actionResult$) {\n        return actionResult$\n            .pipe(exhaustMap((ctx) => {\n            switch (ctx.status) {\n                case \"SUCCESSFUL\" /* Successful */:\n                    return of(this._stateStream.getValue());\n                case \"ERRORED\" /* Errored */:\n                    return throwError(ctx.error);\n                default:\n                    return EMPTY;\n            }\n        }))\n            .pipe(shareReplay());\n    }\n}\n/** @nocollapse */ InternalDispatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatcher, deps: [{ token: InternalActions }, { token: InternalDispatchedActionResults }, { token: PluginManager }, { token: StateStream }, { token: InternalNgxsExecutionStrategy }, { token: InternalErrorReporter }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalDispatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatcher, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatcher, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: InternalActions }, { type: InternalDispatchedActionResults }, { type: PluginManager }, { type: StateStream }, { type: InternalNgxsExecutionStrategy }, { type: InternalErrorReporter }]; } });\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = (o) => {\n    Object.freeze(o);\n    const oIsFunction = typeof o === 'function';\n    const hasOwnProp = Object.prototype.hasOwnProperty;\n    Object.getOwnPropertyNames(o).forEach(function (prop) {\n        if (hasOwnProp.call(o, prop) &&\n            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\n            o[prop] !== null &&\n            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n            !Object.isFrozen(o[prop])) {\n            deepFreeze(o[prop]);\n        }\n    });\n    return o;\n};\n\n/**\n * @ignore\n */\nclass InternalStateOperations {\n    constructor(_stateStream, _dispatcher, _config) {\n        this._stateStream = _stateStream;\n        this._dispatcher = _dispatcher;\n        this._config = _config;\n    }\n    /**\n     * Returns the root state operators.\n     */\n    getRootStateOperations() {\n        const rootStateOperations = {\n            getState: () => this._stateStream.getValue(),\n            setState: (newState) => this._stateStream.next(newState),\n            dispatch: (actionOrActions) => this._dispatcher.dispatch(actionOrActions)\n        };\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            return this._config.developmentMode\n                ? ensureStateAndActionsAreImmutable(rootStateOperations)\n                : rootStateOperations;\n        }\n        else {\n            return rootStateOperations;\n        }\n    }\n    setStateToTheCurrentWithNew(results) {\n        const stateOperations = this.getRootStateOperations();\n        // Get our current stream\n        const currentState = stateOperations.getState();\n        // Set the state to the current + new\n        stateOperations.setState(Object.assign(Object.assign({}, currentState), results.defaults));\n    }\n}\n/** @nocollapse */ InternalStateOperations.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalStateOperations, deps: [{ token: StateStream }, { token: InternalDispatcher }, { token: NgxsConfig }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalStateOperations.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalStateOperations, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalStateOperations, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: StateStream }, { type: InternalDispatcher }, { type: NgxsConfig }]; } });\nfunction ensureStateAndActionsAreImmutable(root) {\n    return {\n        getState: () => root.getState(),\n        setState: value => {\n            const frozenValue = deepFreeze(value);\n            return root.setState(frozenValue);\n        },\n        dispatch: actions => {\n            return root.dispatch(actions);\n        }\n    };\n}\n\nfunction simplePatch(value) {\n    return (existingState) => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (Array.isArray(value)) {\n                throwPatchingArrayError();\n            }\n            else if (typeof value !== 'object') {\n                throwPatchingPrimitiveError();\n            }\n        }\n        const newState = Object.assign({}, existingState);\n        for (const key in value) {\n            // deep clone for patch compatibility\n            newState[key] = value[key];\n        }\n        return newState;\n    };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nclass StateContextFactory {\n    constructor(_internalStateOperations) {\n        this._internalStateOperations = _internalStateOperations;\n    }\n    /**\n     * Create the state context\n     */\n    createStateContext(mappedStore) {\n        const root = this._internalStateOperations.getRootStateOperations();\n        function getState(currentAppState) {\n            return getValue(currentAppState, mappedStore.path);\n        }\n        function setStateValue(currentAppState, newValue) {\n            const newAppState = setValue(currentAppState, mappedStore.path, newValue);\n            root.setState(newAppState);\n            return newAppState;\n            // In doing this refactoring I noticed that there is a 'bug' where the\n            // application state is returned instead of this state slice.\n            // This has worked this way since the beginning see:\n            // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n            // This needs to be fixed, but is a 'breaking' change.\n            // I will do this fix in a subsequent PR and we can decide how to handle it.\n        }\n        function setStateFromOperator(currentAppState, stateOperator) {\n            const local = getState(currentAppState);\n            const newValue = stateOperator(local);\n            return setStateValue(currentAppState, newValue);\n        }\n        function isStateOperator(value) {\n            return typeof value === 'function';\n        }\n        return {\n            getState() {\n                const currentAppState = root.getState();\n                return getState(currentAppState);\n            },\n            patchState(val) {\n                const currentAppState = root.getState();\n                const patchOperator = simplePatch(val);\n                return setStateFromOperator(currentAppState, patchOperator);\n            },\n            setState(val) {\n                const currentAppState = root.getState();\n                return isStateOperator(val)\n                    ? setStateFromOperator(currentAppState, val)\n                    : setStateValue(currentAppState, val);\n            },\n            dispatch(actions) {\n                return root.dispatch(actions);\n            }\n        };\n    }\n}\n/** @nocollapse */ StateContextFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateContextFactory, deps: [{ token: InternalStateOperations }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ StateContextFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateContextFactory, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateContextFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: InternalStateOperations }]; } });\n\nclass StoreValidators {\n    static checkThatStateIsNamedCorrectly(name) {\n        if (!name) {\n            throwStateNamePropertyError();\n        }\n        else if (!this.stateNameRegex.test(name)) {\n            throwStateNameError(name);\n        }\n    }\n    static checkThatStateNameIsUnique(stateName, state, statesByName) {\n        const existingState = statesByName[stateName];\n        if (existingState && existingState !== state) {\n            throwStateUniqueError(stateName, state.name, existingState.name);\n        }\n    }\n    static checkThatStateClassesHaveBeenDecorated(stateClasses) {\n        stateClasses.forEach((stateClass) => {\n            if (!getStoreMetadata$1(stateClass)) {\n                throwStateDecoratorError(stateClass.name);\n            }\n        });\n    }\n}\nStoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n    if (jit_hasInjectableAnnotation(stateClass) || aot_hasNgInjectableDef(stateClass)) {\n        return;\n    }\n    console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));\n}\nfunction aot_hasNgInjectableDef(stateClass) {\n    // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n    // AOT mode because this property is added before runtime. If an application is running in\n    // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n    // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n    return !!stateClass.ɵprov;\n}\nfunction jit_hasInjectableAnnotation(stateClass) {\n    // `ɵprov` doesn't exist in JIT mode (for instance when running unit tests with Jest).\n    const annotations = stateClass.__annotations__ || [];\n    return annotations.some((annotation) => (annotation === null || annotation === void 0 ? void 0 : annotation.ngMetadataName) === 'Injectable');\n}\n\n/**\n * Init action\n */\nclass InitState {\n    static get type() {\n        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n        return '@@INIT';\n    }\n}\n/**\n * Update action\n */\nclass UpdateState {\n    constructor(addedStates) {\n        this.addedStates = addedStates;\n    }\n    static get type() {\n        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n        return '@@UPDATE_STATE';\n    }\n}\n\nconst NGXS_DEVELOPMENT_OPTIONS = new InjectionToken('NGXS_DEVELOPMENT_OPTIONS', {\n    providedIn: 'root',\n    factory: () => ({ warnOnUnhandledActions: true })\n});\n\nclass NgxsUnhandledActionsLogger {\n    constructor(options) {\n        /**\n         * These actions should be ignored by default; the user can increase this\n         * list in the future via the `ignoreActions` method.\n         */\n        this._ignoredActions = new Set([InitState.type, UpdateState.type]);\n        if (typeof options.warnOnUnhandledActions === 'object') {\n            this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n        }\n    }\n    /**\n     * Adds actions to the internal list of actions that should be ignored.\n     */\n    ignoreActions(...actions) {\n        for (const action of actions) {\n            this._ignoredActions.add(action.type);\n        }\n    }\n    /** @internal */\n    warn(action) {\n        const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n        if (actionShouldBeIgnored) {\n            return;\n        }\n        action =\n            action.constructor && action.constructor.name !== 'Object'\n                ? action.constructor.name\n                : action.type;\n        console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n    }\n}\n/** @nocollapse */ NgxsUnhandledActionsLogger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsUnhandledActionsLogger, deps: [{ token: NGXS_DEVELOPMENT_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NgxsUnhandledActionsLogger.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsUnhandledActionsLogger });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsUnhandledActionsLogger, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXS_DEVELOPMENT_OPTIONS]\n                }] }]; } });\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n/**\n * The `StateFactory` class adds root and feature states to the graph.\n * This extracts state names from state classes, checks if they already\n * exist in the global graph, throws errors if their names are invalid, etc.\n * See its constructor, state factories inject state factories that are\n * parent-level providers. This is required to get feature states from the\n * injector on the same level.\n *\n * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.\n * The `StateFactory` is initialized on the feature level and goes through `...states`\n * to get them from the injector through `injector.get(state)`.\n * @ignore\n */\nclass StateFactory {\n    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n        this._injector = _injector;\n        this._config = _config;\n        this._parentFactory = _parentFactory;\n        this._actions = _actions;\n        this._actionResults = _actionResults;\n        this._stateContextFactory = _stateContextFactory;\n        this._initialState = _initialState;\n        this._actionsSubscription = null;\n        this._states = [];\n        this._statesByName = {};\n        this._statePaths = {};\n        this.getRuntimeSelectorContext = memoize(() => {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const stateFactory = this;\n            function resolveGetter(key) {\n                const path = stateFactory.statePaths[key];\n                return path ? propGetter(path.split('.'), stateFactory._config) : null;\n            }\n            const context = this._parentFactory\n                ? this._parentFactory.getRuntimeSelectorContext()\n                : {\n                    getStateGetter(key) {\n                        let getter = resolveGetter(key);\n                        if (getter) {\n                            return getter;\n                        }\n                        return (...args) => {\n                            // Late loaded getter\n                            if (!getter) {\n                                getter = resolveGetter(key);\n                            }\n                            return getter ? getter(...args) : undefined;\n                        };\n                    },\n                    getSelectorOptions(localOptions) {\n                        const globalSelectorOptions = stateFactory._config.selectorOptions;\n                        return Object.assign(Object.assign({}, globalSelectorOptions), (localOptions || {}));\n                    }\n                };\n            return context;\n        });\n    }\n    get states() {\n        return this._parentFactory ? this._parentFactory.states : this._states;\n    }\n    get statesByName() {\n        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n    }\n    get statePaths() {\n        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n    }\n    static cloneDefaults(defaults) {\n        let value = {};\n        if (Array.isArray(defaults)) {\n            value = defaults.slice();\n        }\n        else if (isObject(defaults)) {\n            value = Object.assign({}, defaults);\n        }\n        else if (defaults === undefined) {\n            value = {};\n        }\n        else {\n            value = defaults;\n        }\n        return value;\n    }\n    ngOnDestroy() {\n        var _a;\n        (_a = this._actionsSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n    /**\n     * Add a new state to the global defs.\n     */\n    add(stateClasses) {\n        if (NG_DEV_MODE) {\n            StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);\n        }\n        const { newStates } = this.addToStatesMap(stateClasses);\n        if (!newStates.length)\n            return [];\n        const stateGraph = buildGraph(newStates);\n        const sortedStates = topologicalSort(stateGraph);\n        const paths = findFullParentPath(stateGraph);\n        const nameGraph = nameToState(newStates);\n        const bootstrappedStores = [];\n        for (const name of sortedStates) {\n            const stateClass = nameGraph[name];\n            const path = paths[name];\n            const meta = stateClass[META_KEY];\n            this.addRuntimeInfoToMeta(meta, path);\n            // Note: previously we called `ensureStateClassIsInjectable` within the\n            // `State` decorator. This check is moved here because the `ɵprov` property\n            // will not exist on the class in JIT mode (because it's set asynchronously\n            // during JIT compilation through `Object.defineProperty`).\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                ensureStateClassIsInjectable(stateClass);\n            }\n            const stateMap = {\n                name,\n                path,\n                isInitialised: false,\n                actions: meta.actions,\n                instance: this._injector.get(stateClass),\n                defaults: StateFactory.cloneDefaults(meta.defaults)\n            };\n            // ensure our store hasn't already been added\n            // but don't throw since it could be lazy\n            // loaded from different paths\n            if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n                bootstrappedStores.push(stateMap);\n            }\n            this.states.push(stateMap);\n        }\n        return bootstrappedStores;\n    }\n    /**\n     * Add a set of states to the store and return the defaults\n     */\n    addAndReturnDefaults(stateClasses) {\n        const classes = stateClasses || [];\n        const mappedStores = this.add(classes);\n        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n        return { defaults, states: mappedStores };\n    }\n    connectActionHandlers() {\n        // Note: We have to connect actions only once when the `StateFactory`\n        //       is being created for the first time. This checks if we're in\n        //       a child state factory and the parent state factory already exists.\n        if (this._parentFactory || this._actionsSubscription !== null) {\n            return;\n        }\n        const dispatched$ = new Subject();\n        this._actionsSubscription = this._actions\n            .pipe(filter((ctx) => ctx.status === \"DISPATCHED\" /* Dispatched */), mergeMap(ctx => {\n            dispatched$.next(ctx);\n            const action = ctx.action;\n            return this.invokeActions(dispatched$, action).pipe(map(() => ({ action, status: \"SUCCESSFUL\" /* Successful */ })), defaultIfEmpty({ action, status: \"CANCELED\" /* Canceled */ }), catchError(error => of({ action, status: \"ERRORED\" /* Errored */, error })));\n        }))\n            .subscribe(ctx => this._actionResults.next(ctx));\n    }\n    /**\n     * Invoke actions on the states.\n     */\n    invokeActions(dispatched$, action) {\n        const type = getActionTypeFromInstance(action);\n        const results = [];\n        // Determines whether the dispatched action has been handled, this is assigned\n        // to `true` within the below `for` loop if any `actionMetas` has been found.\n        let actionHasBeenHandled = false;\n        for (const metadata of this.states) {\n            const actionMetas = metadata.actions[type];\n            if (actionMetas) {\n                for (const actionMeta of actionMetas) {\n                    const stateContext = this._stateContextFactory.createStateContext(metadata);\n                    try {\n                        let result = metadata.instance[actionMeta.fn](stateContext, action);\n                        if (result instanceof Promise) {\n                            result = from(result);\n                        }\n                        if (isObservable(result)) {\n                            // If this observable has been completed w/o emitting\n                            // any value then we wouldn't want to complete the whole chain\n                            // of actions. Since if any observable completes then\n                            // action will be canceled.\n                            // For instance if any action handler would've had such statement:\n                            // `handler(ctx) { return EMPTY; }`\n                            // then the action will be canceled.\n                            // See https://github.com/ngxs/store/issues/1568\n                            result = result.pipe(mergeMap((value) => {\n                                if (value instanceof Promise) {\n                                    return from(value);\n                                }\n                                if (isObservable(value)) {\n                                    return value;\n                                }\n                                return of(value);\n                            }), defaultIfEmpty({}));\n                            if (actionMeta.options.cancelUncompleted) {\n                                // todo: ofActionDispatched should be used with action class\n                                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));\n                            }\n                        }\n                        else {\n                            result = of({}).pipe(shareReplay());\n                        }\n                        results.push(result);\n                    }\n                    catch (e) {\n                        results.push(throwError(e));\n                    }\n                    actionHasBeenHandled = true;\n                }\n            }\n        }\n        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n        // only during development.\n        if (NG_DEV_MODE && !actionHasBeenHandled) {\n            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n            // didn't return `null` so we may ensure the module has been imported.\n            if (unhandledActionsLogger) {\n                unhandledActionsLogger.warn(action);\n            }\n        }\n        if (!results.length) {\n            results.push(of({}));\n        }\n        return forkJoin(results);\n    }\n    addToStatesMap(stateClasses) {\n        const newStates = [];\n        const statesMap = this.statesByName;\n        for (const stateClass of stateClasses) {\n            const stateName = getStoreMetadata$1(stateClass).name;\n            if (NG_DEV_MODE) {\n                StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);\n            }\n            const unmountedState = !statesMap[stateName];\n            if (unmountedState) {\n                newStates.push(stateClass);\n                statesMap[stateName] = stateClass;\n            }\n        }\n        return { newStates };\n    }\n    addRuntimeInfoToMeta(meta, path) {\n        this.statePaths[meta.name] = path;\n        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n        // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n        // We will need to come up with an alternative in v4 because this is used by many plugins\n        meta.path = path;\n    }\n    hasBeenMountedAndBootstrapped(name, path) {\n        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n        // This checks whether a state has been already added to the global graph and\n        // its lifecycle is in 'bootstrapped' state.\n        return this.statesByName[name] && valueIsBootstrappedInInitialState;\n    }\n}\n/** @nocollapse */ StateFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateFactory, deps: [{ token: i0.Injector }, { token: NgxsConfig }, { token: StateFactory, optional: true, skipSelf: true }, { token: InternalActions }, { token: InternalDispatchedActionResults }, { token: StateContextFactory }, { token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ StateFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateFactory });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateFactory, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: NgxsConfig }, { type: StateFactory, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: InternalActions }, { type: InternalDispatchedActionResults }, { type: StateContextFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [INITIAL_STATE_TOKEN]\n                }] }]; } });\n\nfunction createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {\n    return (context) => {\n        const { argumentSelectorFunctions, selectorOptions } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n        return function selectFromRoot(rootState) {\n            // Determine arguments from the app state using the selectors\n            const results = argumentSelectorFunctions.map((argFn) => argFn(rootState));\n            // if the lambda tries to access a something on the\n            // state that doesn't exist, it will throw a TypeError.\n            // since this is quite usual behaviour, we simply return undefined if so.\n            try {\n                return memoizedSelectorFn(...results);\n            }\n            catch (ex) {\n                if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n                    return undefined;\n                }\n                throw ex;\n            }\n        };\n    };\n}\nfunction createMemoizedSelectorFn(originalFn, creationMetadata) {\n    const containerClass = creationMetadata && creationMetadata.containerClass;\n    const wrappedFn = function wrappedSelectorFn(...args) {\n        const returnValue = originalFn.apply(containerClass, args);\n        if (returnValue instanceof Function) {\n            const innerMemoizedFn = memoize.apply(null, [returnValue]);\n            return innerMemoizedFn;\n        }\n        return returnValue;\n    };\n    const memoizedFn = memoize(wrappedFn);\n    Object.setPrototypeOf(memoizedFn, originalFn);\n    return memoizedFn;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n    const localSelectorOptions = selectorMetaData.getSelectorOptions();\n    const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n    const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n    const argumentSelectorFunctions = selectorsToApply.map((selector) => {\n        const factory = getRootSelectorFactory(selector);\n        return factory(context);\n    });\n    return {\n        selectorOptions,\n        argumentSelectorFunctions,\n    };\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n    const selectorsToApply = [];\n    const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;\n    if (containerClass && canInjectContainerState) {\n        // If we are on a state class, add it as the first selector parameter\n        const metadata = getStoreMetadata$1(containerClass);\n        if (metadata) {\n            selectorsToApply.push(containerClass);\n        }\n    }\n    if (selectors) {\n        selectorsToApply.push(...selectors);\n    }\n    return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n    const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n    return (metadata && metadata.makeRootSelector) || (() => selector);\n}\n\n// tslint:disable:unified-signatures\nclass Store {\n    constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n        this._stateStream = _stateStream;\n        this._internalStateOperations = _internalStateOperations;\n        this._config = _config;\n        this._internalExecutionStrategy = _internalExecutionStrategy;\n        this._stateFactory = _stateFactory;\n        /**\n         * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n         * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n         * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n         */\n        this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({ bufferSize: 1, refCount: true }));\n        this.initStateStream(initialStateValue);\n    }\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions) {\n        return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n    }\n    select(selector) {\n        const selectorFn = this.getStoreBoundSelectorFn(selector);\n        return this._selectableStateStream.pipe(map(selectorFn), catchError((err) => {\n            // if error is TypeError we swallow it to prevent usual errors with property access\n            const { suppressErrors } = this._config.selectorOptions;\n            if (err instanceof TypeError && suppressErrors) {\n                return of(undefined);\n            }\n            // rethrow other errors\n            return throwError(err);\n        }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n    }\n    selectOnce(selector) {\n        return this.select(selector).pipe(take(1));\n    }\n    selectSnapshot(selector) {\n        const selectorFn = this.getStoreBoundSelectorFn(selector);\n        return selectorFn(this._stateStream.getValue());\n    }\n    /**\n     * Allow the user to subscribe to the root of the state\n     */\n    subscribe(fn) {\n        return this._selectableStateStream\n            .pipe(leaveNgxs(this._internalExecutionStrategy))\n            .subscribe(fn);\n    }\n    /**\n     * Return the raw value of the state.\n     */\n    snapshot() {\n        return this._internalStateOperations.getRootStateOperations().getState();\n    }\n    /**\n     * Reset the state to a specific point in time. This method is useful\n     * for plugin's who need to modify the state directly or unit testing.\n     */\n    reset(state) {\n        return this._internalStateOperations.getRootStateOperations().setState(state);\n    }\n    getStoreBoundSelectorFn(selector) {\n        const makeSelectorFn = getRootSelectorFactory(selector);\n        const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n        return makeSelectorFn(runtimeContext);\n    }\n    initStateStream(initialStateValue) {\n        const value = this._stateStream.value;\n        const storeIsEmpty = !value || Object.keys(value).length === 0;\n        if (storeIsEmpty) {\n            const defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;\n            const storeValues = defaultStateNotEmpty\n                ? Object.assign(Object.assign({}, this._config.defaultsState), initialStateValue) : initialStateValue;\n            this._stateStream.next(storeValues);\n        }\n    }\n}\n/** @nocollapse */ Store.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Store, deps: [{ token: StateStream }, { token: InternalStateOperations }, { token: NgxsConfig }, { token: InternalNgxsExecutionStrategy }, { token: StateFactory }, { token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ Store.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Store, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Store, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: StateStream }, { type: InternalStateOperations }, { type: NgxsConfig }, { type: InternalNgxsExecutionStrategy }, { type: StateFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [INITIAL_STATE_TOKEN]\n                }] }]; } });\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nclass SelectFactory {\n    constructor(store, config) {\n        SelectFactory.store = store;\n        SelectFactory.config = config;\n    }\n    ngOnDestroy() {\n        SelectFactory.store = null;\n        SelectFactory.config = null;\n    }\n}\nSelectFactory.store = null;\nSelectFactory.config = null;\n/** @nocollapse */ SelectFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: SelectFactory, deps: [{ token: Store }, { token: NgxsConfig }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ SelectFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: SelectFactory, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: SelectFactory, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: Store }, { type: NgxsConfig }]; } });\n\nclass LifecycleStateManager {\n    constructor(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {\n        this._store = _store;\n        this._internalErrorReporter = _internalErrorReporter;\n        this._internalStateOperations = _internalStateOperations;\n        this._stateContextFactory = _stateContextFactory;\n        this._bootstrapper = _bootstrapper;\n        this._destroy$ = new Subject();\n    }\n    ngOnDestroy() {\n        this._destroy$.next();\n    }\n    ngxsBootstrap(action, results) {\n        this._internalStateOperations\n            .getRootStateOperations()\n            .dispatch(action)\n            .pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._bootstrapper.appBootstrapped$), filter(appBootstrapped => !!appBootstrapped), catchError(error => {\n            // The `SafeSubscriber` (which is used by most RxJS operators) re-throws\n            // errors asynchronously (`setTimeout(() => { throw error })`). This might\n            // break existing user's code or unit tests. We catch the error manually to\n            // be backward compatible with the old behavior.\n            this._internalErrorReporter.reportErrorSafely(error);\n            return EMPTY;\n        }), takeUntil(this._destroy$))\n            .subscribe(() => this._invokeBootstrapOnStates(results.states));\n    }\n    _invokeInitOnStates(mappedStores) {\n        for (const mappedStore of mappedStores) {\n            const instance = mappedStore.instance;\n            if (instance.ngxsOnChanges) {\n                this._store\n                    .select(state => getValue(state, mappedStore.path))\n                    .pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$))\n                    .subscribe(([previousValue, currentValue]) => {\n                    const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n                    instance.ngxsOnChanges(change);\n                });\n            }\n            if (instance.ngxsOnInit) {\n                instance.ngxsOnInit(this._getStateContext(mappedStore));\n            }\n            mappedStore.isInitialised = true;\n        }\n    }\n    _invokeBootstrapOnStates(mappedStores) {\n        for (const mappedStore of mappedStores) {\n            const instance = mappedStore.instance;\n            if (instance.ngxsAfterBootstrap) {\n                instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n            }\n        }\n    }\n    _getStateContext(mappedStore) {\n        return this._stateContextFactory.createStateContext(mappedStore);\n    }\n}\n/** @nocollapse */ LifecycleStateManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: LifecycleStateManager, deps: [{ token: Store }, { token: InternalErrorReporter }, { token: InternalStateOperations }, { token: StateContextFactory }, { token: i5.NgxsBootstrapper }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ LifecycleStateManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: LifecycleStateManager, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: LifecycleStateManager, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: Store }, { type: InternalErrorReporter }, { type: InternalStateOperations }, { type: StateContextFactory }, { type: i5.NgxsBootstrapper }]; } });\n\n/**\n * Root module\n * @ignore\n */\nclass NgxsRootModule {\n    constructor(factory, internalStateOperations, _store, _select, states = [], lifecycleStateManager) {\n        // Add stores to the state graph and return their defaults\n        const results = factory.addAndReturnDefaults(states);\n        internalStateOperations.setStateToTheCurrentWithNew(results);\n        // Connect our actions stream\n        factory.connectActionHandlers();\n        // Dispatch the init action and invoke init and bootstrap functions after\n        lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n    }\n}\n/** @nocollapse */ NgxsRootModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule, deps: [{ token: StateFactory }, { token: InternalStateOperations }, { token: Store }, { token: SelectFactory }, { token: ROOT_STATE_TOKEN, optional: true }, { token: LifecycleStateManager }], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsRootModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule });\n/** @nocollapse */ NgxsRootModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: function () { return [{ type: StateFactory }, { type: InternalStateOperations }, { type: Store }, { type: SelectFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [ROOT_STATE_TOKEN]\n                }] }, { type: LifecycleStateManager }]; } });\n\n/**\n * Feature module\n * @ignore\n */\nclass NgxsFeatureModule {\n    constructor(_store, internalStateOperations, factory, states = [], lifecycleStateManager) {\n        // Since FEATURE_STATE_TOKEN is a multi token, we need to\n        // flatten it [[Feature1State, Feature2State], [Feature3State]]\n        const flattenedStates = NgxsFeatureModule.flattenStates(states);\n        // add stores to the state graph and return their defaults\n        const results = factory.addAndReturnDefaults(flattenedStates);\n        if (results.states.length) {\n            internalStateOperations.setStateToTheCurrentWithNew(results);\n            // dispatch the update action and invoke init and bootstrap functions after\n            lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n        }\n    }\n    static flattenStates(states = []) {\n        return states.reduce((total, values) => total.concat(values), []);\n    }\n}\n/** @nocollapse */ NgxsFeatureModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule, deps: [{ token: Store }, { token: InternalStateOperations }, { token: StateFactory }, { token: FEATURE_STATE_TOKEN, optional: true }, { token: LifecycleStateManager }], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsFeatureModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule });\n/** @nocollapse */ NgxsFeatureModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: function () { return [{ type: Store }, { type: InternalStateOperations }, { type: StateFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FEATURE_STATE_TOKEN]\n                }] }, { type: LifecycleStateManager }]; } });\n\n/**\n * Ngxs Module\n */\nclass NgxsModule {\n    /**\n     * Root module factory\n     */\n    static forRoot(states = [], options = {}) {\n        return {\n            ngModule: NgxsRootModule,\n            providers: [\n                StateFactory,\n                PluginManager,\n                ...states,\n                ...NgxsModule.ngxsTokenProviders(states, options)\n            ]\n        };\n    }\n    /**\n     * Feature module factory\n     */\n    static forFeature(states = []) {\n        return {\n            ngModule: NgxsFeatureModule,\n            providers: [\n                // This is required on the feature level, see comments in `state-factory.ts`.\n                StateFactory,\n                PluginManager,\n                ...states,\n                {\n                    provide: FEATURE_STATE_TOKEN,\n                    multi: true,\n                    useValue: states\n                }\n            ]\n        };\n    }\n    static ngxsTokenProviders(states, options) {\n        return [\n            {\n                provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,\n                useValue: options.executionStrategy\n            },\n            {\n                provide: ROOT_STATE_TOKEN,\n                useValue: states\n            },\n            {\n                provide: ROOT_OPTIONS,\n                useValue: options\n            },\n            {\n                provide: APP_BOOTSTRAP_LISTENER,\n                useFactory: NgxsModule.appBootstrapListenerFactory,\n                multi: true,\n                deps: [NgxsBootstrapper]\n            },\n            {\n                provide: ɵNGXS_STATE_CONTEXT_FACTORY,\n                useExisting: StateContextFactory\n            },\n            {\n                provide: ɵNGXS_STATE_FACTORY,\n                useExisting: StateFactory\n            }\n        ];\n    }\n    static appBootstrapListenerFactory(bootstrapper) {\n        return () => bootstrapper.bootstrap();\n    }\n}\n/** @nocollapse */ NgxsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule });\n/** @nocollapse */ NgxsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule, decorators: [{\n            type: NgModule\n        }] });\n\n/**\n * Decorates a method with a action information.\n */\nfunction Action(actions, options) {\n    return (target, name) => {\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const isStaticMethod = target.hasOwnProperty('prototype');\n            if (isStaticMethod) {\n                throwActionDecoratorError();\n            }\n        }\n        const meta = ensureStoreMetadata$1(target.constructor);\n        if (!Array.isArray(actions)) {\n            actions = [actions];\n        }\n        for (const action of actions) {\n            const type = action.type;\n            if (!meta.actions[type]) {\n                meta.actions[type] = [];\n            }\n            meta.actions[type].push({\n                fn: name,\n                options: options || {},\n                type\n            });\n        }\n    };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n    function getStateOptions(inheritedStateClass) {\n        const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};\n        return Object.assign(Object.assign({}, inheritanceOptions), options);\n    }\n    function mutateMetaData(params) {\n        const { meta, inheritedStateClass, optionsWithInheritance } = params;\n        const { children, defaults, name } = optionsWithInheritance;\n        const stateName = typeof name === 'string' ? name : (name && name.getName()) || null;\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            StoreValidators.checkThatStateIsNamedCorrectly(stateName);\n        }\n        if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n            const inheritedMeta = inheritedStateClass[META_KEY] || {};\n            meta.actions = Object.assign(Object.assign({}, meta.actions), inheritedMeta.actions);\n        }\n        meta.children = children;\n        meta.defaults = defaults;\n        meta.name = stateName;\n    }\n    return (target) => {\n        const stateClass = target;\n        const meta = ensureStoreMetadata$1(stateClass);\n        const inheritedStateClass = Object.getPrototypeOf(stateClass);\n        const optionsWithInheritance = getStateOptions(inheritedStateClass);\n        mutateMetaData({ meta, inheritedStateClass, optionsWithInheritance });\n        stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n    };\n}\n\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n    if (!SelectFactory.store) {\n        throwSelectFactoryNotConnectedError();\n    }\n    return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n    rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n    if (typeof rawSelector === 'string') {\n        const propsArray = paths.length\n            ? [rawSelector, ...paths]\n            : rawSelector.split('.');\n        return propGetter(propsArray, SelectFactory.config);\n    }\n    return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n    const lastCharIndex = name.length - 1;\n    const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n */\nfunction Select(rawSelector, ...paths) {\n    return function (target, key) {\n        const name = key.toString();\n        const selectorId = `__${name}__selector`;\n        const selector = createSelectorFn(name, rawSelector, paths);\n        Object.defineProperties(target, {\n            [selectorId]: {\n                writable: true,\n                enumerable: false,\n                configurable: true\n            },\n            [name]: {\n                enumerable: true,\n                configurable: true,\n                get() {\n                    return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n                }\n            }\n        });\n    };\n}\n\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n    getOptions: (target) => {\n        return (target && target[SELECTOR_OPTIONS_META_KEY]) || {};\n    },\n    defineOptions: (target, options) => {\n        if (!target)\n            return;\n        target[SELECTOR_OPTIONS_META_KEY] = options;\n    },\n};\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n    const selectorMetaData = ensureSelectorMetadata$1(originalFn);\n    selectorMetaData.originalFn = originalFn;\n    let getExplicitSelectorOptions = () => ({});\n    if (creationMetadata) {\n        selectorMetaData.containerClass = creationMetadata.containerClass;\n        selectorMetaData.selectorName = creationMetadata.selectorName || null;\n        getExplicitSelectorOptions =\n            creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n    }\n    const selectorMetaDataClone = Object.assign({}, selectorMetaData);\n    selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n    return selectorMetaData;\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, (selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {})), (selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {})), (selectorMetaData.getSelectorOptions() || {})), explicitOptions);\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n    return (function decorate(target, methodName, descriptor) {\n        if (methodName) {\n            descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, methodName));\n            // Method Decorator\n            const originalFn = descriptor.value || descriptor.originalFn;\n            if (originalFn) {\n                selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n            }\n        }\n        else {\n            // Class Decorator\n            selectorOptionsMetaAccessor.defineOptions(target, options);\n        }\n    });\n}\n\nfunction ensureStoreMetadata(target) {\n    return ensureStoreMetadata$1(target);\n}\nfunction getStoreMetadata(target) {\n    return getStoreMetadata$1(target);\n}\nfunction ensureSelectorMetadata(target) {\n    return ensureSelectorMetadata$1(target);\n}\nfunction getSelectorMetadata(target) {\n    return getSelectorMetadata$1(target);\n}\n\nfunction createSelector(selectors, projector, creationMetadata) {\n    const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);\n    const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);\n    selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);\n    return memoizedFn;\n}\n\nfunction Selector(selectors) {\n    return (target, key, descriptor) => {\n        descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, key));\n        const originalFn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (originalFn && typeof originalFn !== 'function') {\n                throwSelectorDecoratorError();\n            }\n        }\n        const memoizedFn = createSelector(selectors, originalFn, {\n            containerClass: target,\n            selectorName: key.toString(),\n            getSelectorOptions() {\n                return {};\n            },\n        });\n        const newDescriptor = {\n            configurable: true,\n            get() {\n                return memoizedFn;\n            },\n        };\n        // Add hidden property to descriptor\n        newDescriptor['originalFn'] = originalFn;\n        return newDescriptor;\n    };\n}\n\nclass StateToken {\n    constructor(name) {\n        this.name = name;\n        const selectorMetadata = ensureSelectorMetadata$1(this);\n        selectorMetadata.makeRootSelector = (runtimeContext) => {\n            return runtimeContext.getStateGetter(this.name);\n        };\n    }\n    getName() {\n        return this.name;\n    }\n    toString() {\n        return `StateToken[${this.name}]`;\n    }\n}\n\nclass NgxsDevelopmentModule {\n    static forRoot(options) {\n        return {\n            ngModule: NgxsDevelopmentModule,\n            providers: [\n                NgxsUnhandledActionsLogger,\n                { provide: NGXS_DEVELOPMENT_OPTIONS, useValue: options }\n            ]\n        };\n    }\n}\n/** @nocollapse */ NgxsDevelopmentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsDevelopmentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule });\n/** @nocollapse */ NgxsDevelopmentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule, decorators: [{\n            type: NgModule\n        }] });\n\nfunction ensureValidSelector(selector, context = {}) {\n    const noun = context.noun || 'selector';\n    const prefix = context.prefix ? context.prefix + ': ' : '';\n    ensureValueProvided(selector, { noun, prefix: context.prefix });\n    const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n    if (!metadata) {\n        throw new Error(`${prefix}The value provided as the ${noun} is not a valid selector.`);\n    }\n}\nfunction ensureValueProvided(value, context = {}) {\n    const noun = context.noun || 'value';\n    const prefix = context.prefix ? context.prefix + ': ' : '';\n    if (!value) {\n        throw new Error(`${prefix}A ${noun} must be provided.`);\n    }\n}\n\nfunction createModelSelector(selectorMap) {\n    const selectorKeys = Object.keys(selectorMap);\n    const selectors = Object.values(selectorMap);\n    ensureValidSelectorMap({\n        prefix: '[createModelSelector]',\n        selectorMap,\n        selectorKeys,\n        selectors,\n    });\n    return createSelector(selectors, (...args) => {\n        return selectorKeys.reduce((obj, key, index) => {\n            obj[key] = args[index];\n            return obj;\n        }, {});\n    });\n}\nfunction ensureValidSelectorMap({ prefix, selectorMap, selectorKeys, selectors, }) {\n    ensureValueProvided(selectorMap, { prefix, noun: 'selector map' });\n    ensureValueProvided(typeof selectorMap === 'object', { prefix, noun: 'valid selector map' });\n    ensureValueProvided(selectorKeys.length, { prefix, noun: 'non-empty selector map' });\n    selectors.forEach((selector, index) => ensureValidSelector(selector, {\n        prefix,\n        noun: `selector for the '${selectorKeys[index]}' property`,\n    }));\n}\n\nfunction createPickSelector(selector, keys) {\n    ensureValidSelector(selector, { prefix: '[createPickSelector]' });\n    const validKeys = keys.filter(Boolean);\n    const selectors = validKeys.map((key) => createSelector([selector], (s) => s[key]));\n    return createSelector([...selectors], (...props) => {\n        return validKeys.reduce((acc, key, index) => {\n            acc[key] = props[index];\n            return acc;\n        }, {});\n    });\n}\n\nfunction createPropertySelectors(parentSelector) {\n    ensureValidSelector(parentSelector, {\n        prefix: '[createPropertySelectors]',\n        noun: 'parent selector',\n    });\n    const cache = {};\n    return new Proxy({}, {\n        get(_target, prop) {\n            const selector = cache[prop] ||\n                createSelector([parentSelector], (s) => s === null || s === void 0 ? void 0 : s[prop]);\n            cache[prop] = selector;\n            return selector;\n        },\n    });\n}\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, Actions, InitState, NGXS_PLUGINS, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, StateStream, StateToken, Store, UpdateState, actionMatcher, createModelSelector, createPickSelector, createPropertySelectors, createSelector, ensureSelectorMetadata, ensureStoreMetadata, getActionTypeFromInstance, getSelectorMetadata, getStoreMetadata, getValue, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, setValue, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}